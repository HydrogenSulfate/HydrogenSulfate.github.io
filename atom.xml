<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blackops</title>
  
  <subtitle>初心易得，始终难守</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hydrogensulfate.github.io/"/>
  <updated>2020-03-16T07:50:58.115Z</updated>
  <id>https://hydrogensulfate.github.io/</id>
  
  <author>
    <name>Blackops</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RQNOJ-83 魔兽世界（BFS+带“传送门”路径的通用方法）</title>
    <link href="https://hydrogensulfate.github.io/2020/03/16/RQNOJ-83/"/>
    <id>https://hydrogensulfate.github.io/2020/03/16/RQNOJ-83/</id>
    <published>2020-03-16T07:35:01.000Z</published>
    <updated>2020-03-16T07:50:58.115Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong></p><p>小A在WOW中是个小术士.作为一名术士,不会单刷副本是相当丢脸的.所谓单刷副本就是单挑BOSS了,这么有荣誉感的事小A怎么会不做呢?于是小A来到了厄运之槌开始了单刷.小A看了看,厄运之槌的地图是一个N*M的矩形（N，M&lt;=100）,上面遍布了小怪和传送门.例如（1表示有小怪，0表示无小怪,大写字母表示传送门,传送门:例如,走到 B 传送门点将传送到另一个 B 传送点（次数无限，但每次进入传送点只传送过去，不会在传送回来）数据保证每个传送门有且仅有相对应的另一个传送门）:</p><p><img src="http://www.rqnoj.cn/ProblemPic/P83_1.jpg" alt="img"></p><p>而入口在左上方（1，1）,BOSS却躲在右下方（N，M）.小A非常急切的想要完成单刷然后去向其他那些战士啊盗贼啊不会单刷的职业炫耀炫耀,所以呢,小A绝不会在小怪身上浪费时间(当然是绕开他们),并且想通过传送门尽快到达BOSS身边.看啊看,想啊想,还是没找出最快的路.终于,灵机一动,想什么啊,编程呗!</p><p>路线如图：</p><p><img src="http://www.rqnoj.cn/ProblemPic/P83_2.jpg" alt="img"></p><p>[数据规模]</p><p>对60%的数据,n,m&lt;=20</p><p>对100%的数据,n,m&lt;=100</p><p><img src="http://www.rqnoj.cn/ProblemPic/P83_3.jpg" alt="img"></p><p><strong>输入格式</strong></p><p>第一行2个数据：n m；</p><p>下面n行，每行m个数（入口点和BOSS点无怪和传送门），表示厄运之槌的地图。地图数据之间无空格。每步只能走一格，方向上下左右。左上角为入口点,右下角为出口点.</p><p><strong>输出格式</strong></p><p>一个整数，表示小A最少需要走多少步。如果小A不能走到目标，则输出No Solution.</p><hr><p>题目链接：<a href="[http://localhost:4000/2018/03/05/BZOJ-1001-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/](http://localhost:4000/2018/03/05/BZOJ-1001-狼抓兔子/">RQNOJ 83</a>)</p><p>题目本身很简单，个人感觉比较难处理的是进出传送门的情况，比如从一个门进去，另一个门出来，如何分情况做标记。从另一个角度可以发现，传送门的用途总是从一个点传送到另一个点，然后从另一个点继续往外走，那么可以直接合并这两步，不需要传送门之间连边，而是传送门向对应的门的合法邻域内的点连边，这样很简单就将带<strong>传送门</strong>的搜索问题变成了一般的问题，假如还要求要记录路径，那么把这些特殊的边打上标记，走的时候记录下来就可以了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">char</span> G[N][N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, w;</span><br><span class="line">    edge() &#123;&#125;;</span><br><span class="line">    edge(<span class="keyword">int</span> _to, <span class="keyword">int</span> _nxt, <span class="keyword">int</span> _w): to(_to), nxt(_nxt), w(_w) &#123;&#125;;</span><br><span class="line">&#125; E[N * N * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> head[N * N], tot;</span><br><span class="line"><span class="keyword">int</span> dis[N * N], vis[N * N], dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">pii trans[<span class="number">27</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">27</span>; ++i)</span><br><span class="line">        trans[i][<span class="number">0</span>] = trans[i][<span class="number">1</span>] = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[tot] = edge(t, head[s], w);</span><br><span class="line">    head[s] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(dis, INF);</span><br><span class="line">    clr(vis, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">    q.push_back(s);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop_front();</span><br><span class="line">        vis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = E[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[u] + E[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[u] + E[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!q.empty() &amp;&amp; dis[v] &lt; dis[q.front()])</span><br><span class="line">                        q.push_front(v);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        q.push_back(v);</span><br><span class="line">                    vis[v] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, G[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isupper</span>(G[i][j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = G[i][j] - <span class="string">'A'</span>;</span><br><span class="line">                <span class="keyword">if</span>(trans[x][<span class="number">0</span>].first == <span class="number">-1</span>)</span><br><span class="line">                    trans[x][<span class="number">0</span>] = &#123;i, j&#125;;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    trans[x][<span class="number">1</span>] = &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G[i][j] == <span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> ii = i + dir[k][<span class="number">0</span>], jj = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(chk(ii, jj) &amp;&amp; G[ii][jj] != <span class="string">'1'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        add(i * m + j, ii * m + jj, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isupper</span>(G[i][j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x = G[i][j] - <span class="string">'A'</span>;</span><br><span class="line">                <span class="keyword">if</span>(trans[x][<span class="number">0</span>] == make_pair(i, j))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> ii = trans[x][<span class="number">1</span>].first, jj = trans[x][<span class="number">1</span>].second;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> iii = ii + dir[k][<span class="number">0</span>], jjj = jj + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(chk(iii, jjj) &amp;&amp; G[iii][jjj] != <span class="string">'1'</span>)</span><br><span class="line">                            add(i * m + j, iii * m + jjj, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> ii = trans[x][<span class="number">0</span>].first, jj = trans[x][<span class="number">0</span>].second;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> iii = ii + dir[k][<span class="number">0</span>], jjj = jj + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(chk(iii, jjj) &amp;&amp; G[iii][jjj] != <span class="string">'1'</span>)</span><br><span class="line">                            add(i * m + j, iii * m + jjj, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    spfa(<span class="number">0</span>);</span><br><span class="line">    dis[n * m - <span class="number">1</span>] == INF ? <span class="built_in">puts</span>(<span class="string">"No Solution."</span>) : <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[n * m - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小A在WOW中是个小术士.作为一名术士,不会单刷副本是相当丢脸的.所谓单刷副本就是单挑BOSS了,这么有荣誉感的事小A怎么会不做呢?于是小A来到了厄运之槌开始了单刷.小A看了看,厄运之槌的地图是一个N*M的矩形（N，
      
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="搜索" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="BFS" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%90%9C%E7%B4%A2/BFS/"/>
    
    
      <category term="BFS" scheme="https://hydrogensulfate.github.io/tags/BFS/"/>
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>K-means聚类算法的简单numpy实现</title>
    <link href="https://hydrogensulfate.github.io/2019/10/28/K-means%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95numpy%E5%AE%9E%E7%8E%B0/"/>
    <id>https://hydrogensulfate.github.io/2019/10/28/K-means聚类算法的简单numpy实现/</id>
    <published>2019-10-28T11:50:41.000Z</published>
    <updated>2019-10-29T01:55:52.481Z</updated>
    
    <content type="html"><![CDATA[<p><code>K-means</code>算法作为一种无监督的学习算法，其实现思路比较简单，就是根据当前设定的$K$个聚类点$p_1,p_2…p_i…p_k$，按照给定的距离公式将每一个点归类到对应的簇$C_i$中，然后对每一个簇重新计算它目前的新聚类点坐标$p_i’$，然后看这个新聚类点是否与聚类之前设定的聚类点$p_i$相同，如果不相同，那么更新这个聚类点，然后继续处理下个簇，直到每个簇的聚类点都不会再发生变化。<a id="more"></a></p><p>代码实现的时候参考了网上的伪代码：<br><img src="https://i.loli.net/2019/10/28/5NZUfp7RMIjAl3y.png" alt="kmeas_algo.png"></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.sum((a - b) ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(points, k=<span class="number">5</span>, disthre=<span class="number">1e-5</span>)</span>:</span></span><br><span class="line">    n_points = len(points)</span><br><span class="line">    centroid_indexs = np.random.choice(range(n_points), k)</span><br><span class="line">    centroid_coords = points[centroid_indexs]</span><br><span class="line">    labels = [<span class="number">-1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n_points)]</span><br><span class="line">    max_proc_cnt = <span class="number">1000</span>  <span class="comment"># max process count</span></span><br><span class="line">    proc_cnt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span> <span class="keyword">and</span> (proc_cnt &lt; max_proc_cnt):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n_points):</span><br><span class="line">            point_rep = np.repeat(np.expand_dims(points[i], <span class="number">0</span>), repeats=k, axis=<span class="number">0</span>)</span><br><span class="line">            point_rep = np.sqrt(np.sum((point_rep - centroid_coords) ** <span class="number">2</span>, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>))</span><br><span class="line">            centroid_min_oriIndex = np.argmin(point_rep, axis=<span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">            labels[i] = centroid_min_oriIndex</span><br><span class="line"></span><br><span class="line">        centroid_updated = <span class="literal">False</span></span><br><span class="line">        <span class="comment"># for i, centroids_index in enumerate(centroids_indexs):</span></span><br><span class="line">        <span class="keyword">for</span> i, centroid_coord <span class="keyword">in</span> enumerate(centroid_coords):</span><br><span class="line">            <span class="comment"># get centroids_index's sub_points</span></span><br><span class="line">            cluster_points = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n_points):</span><br><span class="line">                <span class="keyword">if</span> labels[j] == i:</span><br><span class="line">                    cluster_points.append(points[j])</span><br><span class="line">            cluster_points = np.concatenate([cluster_points], axis=<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># cal new_centroid_coord</span></span><br><span class="line">            new_centroid_coord = np.sum(cluster_points, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>) / len(cluster_points)</span><br><span class="line">            <span class="keyword">if</span> dis(centroid_coord, new_centroid_coord) &gt; disthre:</span><br><span class="line">                centroid_coords[i] = new_centroid_coord</span><br><span class="line">                centroid_updated = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> centroid_updated:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        proc_cnt += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'fnished with &#123;0&#125;(s) loop'</span>.format(proc_cnt))</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmeans_demo</span><span class="params">()</span>:</span></span><br><span class="line">    n_points = <span class="number">100</span></span><br><span class="line">    n_clusters = <span class="number">5</span></span><br><span class="line">    X = np.random.rand(n_points, <span class="number">2</span>) * n_points</span><br><span class="line">    colors = [<span class="string">'pink'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'cyan'</span>]</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    ax1 = plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    ax2 = plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.title(<span class="string">'K-means demo(k=&#123;0&#125;)'</span>.format(n_clusters), fontsize=<span class="string">'large'</span>, fontweight=<span class="string">'bold'</span>)</span><br><span class="line"></span><br><span class="line">    plt.sca(ax1)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], marker=<span class="string">'.'</span>, color=<span class="string">'red'</span>, s=<span class="number">20</span>, label=<span class="string">'First'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># process begin</span></span><br><span class="line">    labels = func(points=X, k=n_clusters, disthre=<span class="number">1e-7</span>)</span><br><span class="line">    <span class="comment"># process end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># show the results with pyplot and output my simple statics</span></span><br><span class="line">    plt.sca(ax2)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n_points):</span><br><span class="line">        plt.scatter(X[i, <span class="number">0</span>], X[i, <span class="number">1</span>], marker=<span class="string">'.'</span>, color=colors[labels[i]], s=<span class="number">20</span>, label=<span class="string">'Second'</span>)</span><br><span class="line">    print(labels)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> cid <span class="keyword">in</span> range(n_clusters):</span><br><span class="line">        print(<span class="string">'&#123;0&#125; cluster(colored &#123;1&#125;) has &#123;2&#125; points'</span>.format(cid, colors[cid], labels.count(cid)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    kmeans_demo()</span><br></pre></td></tr></table></figure><p>效果：<img src="https://s2.ax1x.com/2019/10/29/K2lIDx.png" alt="K2lIDx.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;K-means&lt;/code&gt;算法作为一种无监督的学习算法，其实现思路比较简单，就是根据当前设定的$K$个聚类点$p_1,p_2…p_i…p_k$，按照给定的距离公式将每一个点归类到对应的簇$C_i$中，然后对每一个簇重新计算它目前的新聚类点坐标$p_i’$，然后看这个新聚类点是否与聚类之前设定的聚类点$p_i$相同，如果不相同，那么更新这个聚类点，然后继续处理下个簇，直到每个簇的聚类点都不会再发生变化。
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hydrogensulfate.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="numpy" scheme="https://hydrogensulfate.github.io/tags/numpy/"/>
    
      <category term="python" scheme="https://hydrogensulfate.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>一种排列下的子光圈图像合成光场原图像的方法</title>
    <link href="https://hydrogensulfate.github.io/2019/10/20/%E4%B8%80%E7%A7%8D%E6%8E%92%E5%88%97%E4%B8%8B%E7%9A%84%E5%AD%90%E5%85%89%E5%9C%88%E5%9B%BE%E5%83%8F%E5%90%88%E6%88%90%E5%85%89%E5%9C%BA%E5%8E%9F%E5%9B%BE%E5%83%8F%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>https://hydrogensulfate.github.io/2019/10/20/一种排列下的子光圈图像合成光场原图像的方法/</id>
    <published>2019-10-20T13:54:23.000Z</published>
    <updated>2019-10-21T03:03:17.889Z</updated>
    
    <content type="html"><![CDATA[<p>光场相机拍摄的原图(raw文件)的像素之间是按照一定规则排列的，设光场的角分辨率为$U\times V$，子光圈图像分辨率为$X\times Y$，那么这$U\times V$副图像合成后的原图分辨率应该是$(U*X)\times (V*Y)$，但是不同的相机像素排列方式是不同的，这里总结的方法只适用于需要还原回去的原图排列方式为横纵排列，而不是六边形排列之类的</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">xy_size = <span class="number">1080</span></span><br><span class="line">UV_solution = <span class="number">7</span></span><br><span class="line">img_dir = <span class="string">''</span></span><br><span class="line">full_img = np.zeros([xy_size * UV_solution, xy_size * UV_solution, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> img_x <span class="keyword">in</span> range(UV_solution):</span><br><span class="line">    <span class="keyword">for</span> img_y <span class="keyword">in</span> range(UV_solution):</span><br><span class="line">        img_order = img_x * UV_solution + img_y</span><br><span class="line">        img_name = <span class="string">'...'</span></span><br><span class="line">        img_path = os.path.join(img_dir, img_name)</span><br><span class="line">        img_np = np.asarray(Image.open(img_path))</span><br><span class="line">        full_img[img_x::UV_solution, img_y::UV_solution] = img_np</span><br><span class="line"></span><br><span class="line">LF_img = Image.fromarray(full_img.astype(<span class="string">'uint8'</span>)).convert(<span class="string">'RGB'</span>)</span><br><span class="line">LF_img.show()</span><br><span class="line">LF_img_name = img_dir.split(<span class="string">'/'</span>)[<span class="number">-1</span>] + <span class="string">'.png'</span></span><br><span class="line">LF_img_save_path = os.path.dirname(img_dir)</span><br><span class="line">LF_img.save(LF_img_save_path + <span class="string">'/'</span> + LF_img_name)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;光场相机拍摄的原图(raw文件)的像素之间是按照一定规则排列的，设光场的角分辨率为$U\times V$，子光圈图像分辨率为$X\times Y$，那么这$U\times V$副图像合成后的原图分辨率应该是$(U*X)\times (V*Y)$，但是不同的相机像素排列方式是不同的，这里总结的方法只适用于需要还原回去的原图排列方式为横纵排列，而不是六边形排列之类的&lt;/p&gt;
    
    </summary>
    
    
      <category term="光场相关" scheme="https://hydrogensulfate.github.io/categories/%E5%85%89%E5%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="python" scheme="https://hydrogensulfate.github.io/tags/python/"/>
    
      <category term="光场" scheme="https://hydrogensulfate.github.io/tags/%E5%85%89%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1286 Necklace of Beads（Polya入门）</title>
    <link href="https://hydrogensulfate.github.io/2019/10/15/POJ-1286/"/>
    <id>https://hydrogensulfate.github.io/2019/10/15/POJ-1286/</id>
    <published>2019-10-15T04:38:09.000Z</published>
    <updated>2019-10-18T05:08:45.056Z</updated>
    
    <content type="html"><![CDATA[<p>Necklace of Beads<br>Time Limit: 1000MS        Memory Limit: 10000K<br>Total Submissions: 10622        Accepted: 4293<br>Description</p><a id="more"></a><p>Beads of red, blue or green colors are connected together into a circular necklace of n beads ( n &lt; 24 ). If the repetitions that are produced by rotation around the center of the circular necklace or reflection to the axis of symmetry are all neglected, how many different forms of the necklace are there?</p><p>Input</p><p>The input has several lines, and each line contains the input data n.<br>-1 denotes the end of the input file.<br>Output</p><p>The output should contain the output data: Number of different forms, in each line correspondent to the input data.<br>Sample Input</p><p>4<br>5<br>-1<br>Sample Output</p><p>21<br>39</p><p>题目链接：<a href="http://poj.org/problem?id=1286" target="_blank" rel="noopener">POJ 1286</a></p><p>题意就一串长为$n$的珠子可以翻转、旋转，每个珠子可以染$3$种颜色，求本质不同的染色方案数。<br>如果用burnside引理，则会有$3^n$次方种染色方案（标号数），非常麻烦。<br>而用Polya定理：</p><script type="math/tex; mode=display">ans=\sum_{i}{m^{c(p_i)}} /|G|</script><p>其中$m$为染色种数，$|G|$为置换操作个数。$c(p_i)$为某一置换$p_i$中循环的个数。用这个定理就大大缩小了标号数，答案非常好统计。</p><p>具体做法：将每个珠子都编号$1…n$，旋转和翻转看成对珠子编号的置换，由于题目中珠子是圆形的，那么可以有旋转和按照一个对称轴翻转两种情况。</p><ol><li>旋转可以是$0$、每次转$1/n*360$度，每个置换内循环个数为$gcd(i,n)$，共$n$个置换</li><li>翻转分为奇数和偶数两种情况<ol><li>奇数情况每个点和对边中点连线作为作为翻转轴，每个置换均有$(n - 1)/2+1$个循环，共$n$个这样的置换；</li><li>偶数情况每个对边中点连线作为翻转轴，均有$n/2$个循环，有$n/2$个这样的置换；对点两两一组，均有$(n-2)/2+2$个循环，有$n/2$个这样的置换。</li></ol></li></ol><p>所以置换群$G$的总数一定为$2n$，代码中写的麻烦一点是为了方便展示$G$的来源。<br>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">            r *= a;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; ~n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll ans = <span class="number">0</span>;</span><br><span class="line">            ll G = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (ll cc = <span class="number">0</span>; cc &lt; n; ++cc)<span class="comment">///旋转的情况</span></span><br><span class="line">            &#123;</span><br><span class="line">                ll cc_n = __gcd(n, cc);</span><br><span class="line">                ans += qpow(<span class="number">3l</span>l, cc_n);</span><br><span class="line">                ++G;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">///翻转的情况</span></span><br><span class="line">            <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="comment">///奇数每个点和对边作为中心，(n - 1)/2 +1个环，共n个中心</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans += n * (qpow(<span class="number">3l</span>l, (n - <span class="number">1l</span>l) / <span class="number">2l</span>l  + <span class="number">1l</span>l));</span><br><span class="line">                G += n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">///偶数情况每个对边一组，n/2个环，有n/2组；对点一组，(n-2)/2+2个环，有n/2组</span></span><br><span class="line">            &#123;</span><br><span class="line">                ans += (n &gt;&gt; <span class="number">1</span>) * qpow(<span class="number">3l</span>l, ((n - <span class="number">2l</span>l) / <span class="number">2l</span>l + <span class="number">2l</span>l));</span><br><span class="line">                G += (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                ans += (n &gt;&gt; <span class="number">1</span>) * (qpow(<span class="number">3l</span>l, n &gt;&gt; <span class="number">1</span>));</span><br><span class="line">                G += (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans / G &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Necklace of Beads&lt;br&gt;Time Limit: 1000MS        Memory Limit: 10000K&lt;br&gt;Total Submissions: 10622        Accepted: 4293&lt;br&gt;Description&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Polya" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/Polya/"/>
    
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="计数" scheme="https://hydrogensulfate.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
      <category term="Polya" scheme="https://hydrogensulfate.github.io/tags/Polya/"/>
    
  </entry>
  
  <entry>
    <title>numpy.where的两种用法</title>
    <link href="https://hydrogensulfate.github.io/2019/04/16/numpy-where%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95/"/>
    <id>https://hydrogensulfate.github.io/2019/04/16/numpy-where的两种用法/</id>
    <published>2019-04-16T03:32:23.000Z</published>
    <updated>2019-04-16T04:46:25.519Z</updated>
    
    <content type="html"><![CDATA[<p>最近看NMS的实现的时候发现代码里有个np.where(…)[0]，这个0就显得很有灵性了，以为是取第一个元素，后来发现并不是这样。查了一波后用代码自己写了下，发现某些情况下有点和想象的不一样。尤其是这个函数的两种完全不同的用法。</p><a id="more"></a><h1 id="一、np-where-condition"><a href="#一、np-where-condition" class="headerlink" title="一、np.where(condition)"></a>一、np.where(condition)</h1><p>先来份代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">b = a[::<span class="number">-1</span>]</span><br><span class="line">c = np.where(a &gt; b)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'a.shape: '</span>, a.shape)</span><br><span class="line">print(<span class="string">'type(c): '</span>, type(c))</span><br><span class="line">print(<span class="string">'c: '</span>, c)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.shape:  (10,)</span><br><span class="line">type(c):  &lt;class &apos;tuple&apos;&gt;</span><br><span class="line">c:  (array([5, 6, 7, 8, 9], dtype=int64),)</span><br></pre></td></tr></table></figure><p>可以发现输出的类型是<strong>基本元素类型为numpy.ndarray</strong>组成的tuple类（由于单个元素作tuple时，元素后面要加逗号，因此上面的int64括号后有个逗号），那么一维的情况下，得到实际需要的下标就取第一个元素c[0]，像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(c[<span class="number">0</span>]) <span class="comment"># 这里修改成c[0]就可以拿到实际你需要的下表列表</span></span><br></pre></td></tr></table></figure><p>再来个二维的情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">b = np.where(a &gt; <span class="number">3</span>)</span><br><span class="line">print(<span class="string">'a.shape: '</span>, a.shape)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">'b[0]: '</span>, b[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'b[1]: '</span>, b[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.shape:  (2, 3)</span><br><span class="line">(array([1, 1, 1], dtype=int64), array([0, 1, 2], dtype=int64))</span><br><span class="line">b[0]:  [1 1 1]</span><br><span class="line">b[1]:  [0 1 2]</span><br></pre></td></tr></table></figure><p>由此可以发现np.where实际输出的是符合条件的元素本身的下标在各自维度组成的多个<strong>numpy.ndarray</strong>打包成的tuple。这样输出一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(b[<span class="number">0</span>], b[<span class="number">1</span>]):</span><br><span class="line">    print(a[x][y])</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>总结一下，假如condition中有<strong>n</strong>个元素符合条件，设它们为<strong>m</strong>维元素，记为</p><script type="math/tex; mode=display">a^{(i)}[d^{(i)}_1][d^{(i)}_2][d^{(i)}_3]...[d^{(i)}_m], i=1...n</script><p>那么np.where返回的就是</p><script type="math/tex; mode=display">tuple([d^{(1)}_1,d^{(2)}_1,d^{(3)}_1...d^{(n)}_1],[d^{(1)}_2,d^{(2)}_2,d^{(3)}_2...d^{(n)}_2],...,[d^{(1)}_m,d^{(2)}_m,d^{(3)}_m...d^{(n)}_m])</script><hr><h1 id="二、np-where-condition-a-b"><a href="#二、np-where-condition-a-b" class="headerlink" title="二、np.where(condition, a, b)"></a>二、np.where(condition, a, b)</h1><p>此函数比较复杂，讲下简单的用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = a[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">print(np.where(a &gt; b, <span class="literal">True</span>, <span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[False False  True  True]</span><br></pre></td></tr></table></figure><p>输出一个<strong>numpy.ndarray</strong>，shape与condition中比较的参数形状相同，若condition为真，则该位置赋值为a，否则赋值为b。</p><p>二维情况：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">b = a[::<span class="number">-1</span>]</span><br><span class="line">print(b)</span><br><span class="line">print(np.where(a &gt; b, <span class="literal">True</span>, <span class="literal">False</span>))</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[False False False False]</span><br><span class="line"> [ True  True  True  True]]</span><br></pre></td></tr></table></figure><p>个人感觉主要用于减少循环语句的使用，因为python numpy模块就是注重效率和运算向量化，因此有必要加强封装性和减少显式循环代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看NMS的实现的时候发现代码里有个np.where(…)[0]，这个0就显得很有灵性了，以为是取第一个元素，后来发现并不是这样。查了一波后用代码自己写了下，发现某些情况下有点和想象的不一样。尤其是这个函数的两种完全不同的用法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="python" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/python/"/>
    
      <category term="numpy" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/python/numpy/"/>
    
    
      <category term="numpy" scheme="https://hydrogensulfate.github.io/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>压缩存储BitMap简单入门</title>
    <link href="https://hydrogensulfate.github.io/2019/03/14/%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8BitMap%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/"/>
    <id>https://hydrogensulfate.github.io/2019/03/14/压缩存储BitMap简单入门/</id>
    <published>2019-03-14T11:09:01.000Z</published>
    <updated>2019-03-14T12:20:57.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h1><a id="more"></a><p>把数字”哈希”到某一个位置$x$，然后将这个位置标为$1$，代表这个映射位置有值存在了。关键在于如何”哈希”？我的理解是先将数字分到某一块，再把余数作为映射位置（有点像Cache的组相联映射）。</p><p>压缩公式：$x = i*B+j$，$0\le j \lt B$，$B$为用于压缩存储的数字的最大位数，那么$i$就是压缩后存储的块，$j$就是该块中标记$x​$存在的位置</p><p>举个例子，现在将579这个数字放入BitMap，那么$579=18*32+3​$，让BitMap[18]的第3位为1即可。代码就是<code>bit[579 &gt;&gt; 5] |= (1 &lt;&lt; (579 &amp; 31));</code><br>查询操作，就是将查询的数按上述公式分解，去查对应位是否为1即可。<br>取数操作，就是遍历所有的BitMap[i]，若某一位j为1，则说明存在。</p><h1 id="压缩效率简单分析"><a href="#压缩效率简单分析" class="headerlink" title="压缩效率简单分析"></a>压缩效率简单分析</h1><p>假设我们用M位二进制的整数去存N个数字，那么实际上每一个数字最多压缩后占1位，最佳情况只需N/M个整数作为BitMap，因此假如用32位的int，1e9的数字只用3e7+的数字去存储。压缩倍数为$B$倍</p><h1 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h1><p>由于位运算只能有0和1的状态，因此重复的数据只能算一个。</p><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) emplace_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fl(i,f_start,f_end) for(int i=f_start;i&lt;f_end;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fe(i,f_start,f_end) for(int i=f_start;i&lt;=f_end;++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> bit[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clr(bit, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        bit[x &gt;&gt; <span class="number">5</span>] |= (<span class="number">1</span> &lt;&lt; (x &amp; <span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bit[x &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (x &amp; <span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getall() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line">        fl(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            fl(j, <span class="number">0</span>, <span class="number">32</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bit[i] &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    ret.pb((i &lt;&lt; <span class="number">5</span>) + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bitmap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fl(i, <span class="number">0</span>, v.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, v[i], <span class="string">" \n"</span>[i == (<span class="keyword">int</span>)v.size() - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> testnum = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//生成testnum个随机数用于测试</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;test;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    fl(i,<span class="number">0</span>,testnum)</span><br><span class="line">        test.pb(rand() % N);</span><br><span class="line">    sort(all(test));<span class="comment">//排个序便于观察</span></span><br><span class="line"></span><br><span class="line">    show(test);</span><br><span class="line">    fl(i, <span class="number">0</span>, testnum)</span><br><span class="line">    bitmap.insert(test[i]);</span><br><span class="line">    show(bitmap.getall());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;核心思想&quot;&gt;&lt;a href=&quot;#核心思想&quot; class=&quot;headerlink&quot; title=&quot;核心思想&quot;&gt;&lt;/a&gt;核心思想&lt;/h1&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="https://hydrogensulfate.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="位运算" scheme="https://hydrogensulfate.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>HDU复试七门知识点个人版整理</title>
    <link href="https://hydrogensulfate.github.io/2019/03/10/HDU%E5%A4%8D%E8%AF%95%E4%B8%83%E9%97%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%AA%E4%BA%BA%E7%89%88%E6%95%B4%E7%90%86/"/>
    <id>https://hydrogensulfate.github.io/2019/03/10/HDU复试七门知识点个人版整理/</id>
    <published>2019-03-10T05:55:19.000Z</published>
    <updated>2019-03-19T02:31:01.920Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、数据结构（-算法）"><a href="#一、数据结构（-算法）" class="headerlink" title="一、数据结构（+算法）"></a>一、数据结构（+算法）</h1><a id="more"></a><ol><li><p><strong>数组</strong></p><ol><li>寻找数组中第二小的元素：设置$Firstmin$和$Secondmin$更新时分类讨论即可</li><li>找到数组中第一个不重复出现的整数：Hashmap+$O(n)$暴力统计</li></ol></li><li><p><strong>栈</strong></p><ol><li>2个栈模拟1个队列：push暂时存s1，s2里pop；s2被pop为空时将s1的全部push到s2，再在s2里pop</li></ol></li><li><p><strong>队列</strong></p></li><li><p><strong>链表</strong></p><ol><li><p>反转链表：新建一个链表用头插法，返回一个全新的链表L2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp.init(p);</span><br><span class="line">temp-&gt;next = L2-&gt;next;</span><br><span class="line">L2-&gt;next = temp</span><br></pre></td></tr></table></figure></li><li><p>检测链表中的环：快慢指针p1​和p2，若有环则迟早相遇。</p></li><li><p>返回倒数第$k​$个元素：让指针p1比p2早走$k-1​$步，p2到最后一个节点（p2-&gt;next==NULL)时，p1所指即是目标元素</p></li><li><p>无序链表去重$O(n^2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_multielem</span><span class="params">(Node *L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *cur = L-&gt;nxt, *p, *q;</span><br><span class="line">    <span class="keyword">while</span> (cur)</span><br><span class="line">    &#123;</span><br><span class="line">        p = cur;</span><br><span class="line">        q = cur-&gt;nxt;</span><br><span class="line">        <span class="keyword">while</span> (q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(q-&gt;val) == <span class="built_in">abs</span>(cur-&gt;val))<span class="comment">//删除q所指的元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;nxt = q-&gt;nxt;</span><br><span class="line">                q = q-&gt;nxt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                q = q-&gt;nxt;</span><br><span class="line">                p = p-&gt;nxt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol><li><p><strong>树</strong></p><ol><li>检测图是否为树：基图连通、每个结点的父节点只能有一个</li></ol></li><li><p><strong>图</strong></p></li><li><p><strong>字典树</strong></p><ol><li><p>简单实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt[<span class="number">2</span>], v;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i)</span><br><span class="line">            nxt[i] = <span class="number">-1</span>;</span><br><span class="line">        v = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; L[N];</span><br><span class="line"><span class="keyword">int</span> sz;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">newnode</span><span class="params">()</span></span>&#123;</span><br><span class="line">    L[sz].init();</span><br><span class="line">    <span class="keyword">return</span> sz++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(<span class="keyword">char</span> s[], <span class="keyword">int</span> len, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = s[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span> (L[u].nxt[v] == <span class="number">-1</span>)&#123;</span><br><span class="line">            L[u].nxt[v] = newnode();</span><br><span class="line">        &#125;</span><br><span class="line">        u = L[u].nxt[v];</span><br><span class="line">        L[u].cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> val)</span><span class="comment">//查询异或最大值&#123;</span></span></span><br><span class="line">    bitset&lt;31&gt;s(val);</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">int</span> v = s[i];</span><br><span class="line">        <span class="keyword">if</span> (L[L[u].nxt[v ^ <span class="number">1</span>]].cnt)</span><br><span class="line">            u = L[u].nxt[v ^ <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            u = L[u].nxt[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L[u].v;<span class="comment">//返回能与val异或得到最大值的拎一个数L[u].v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>压缩存储BitMap</p><ol><li><p>简单实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> bit[N];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        clr(bit, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        bit[x &gt;&gt; <span class="number">5</span>] |= (<span class="number">1</span> &lt;&lt; (x &amp; <span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bit[x &gt;&gt; <span class="number">5</span>] &amp; (<span class="number">1</span> &lt;&lt; (x &amp; <span class="number">31</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getall() &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ret;</span><br><span class="line">        fl(i, <span class="number">0</span>, N) &#123;</span><br><span class="line">            fl(j, <span class="number">0</span>, <span class="number">32</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bit[i] &amp; (<span class="number">1</span> &lt;&lt; j)) &#123;</span><br><span class="line">                    ret.pb((i &lt;&lt; <span class="number">5</span>) + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;bitmap;</span><br></pre></td></tr></table></figure></li></ol></li></ol><hr><h1 id="二、计算机组成原理"><a href="#二、计算机组成原理" class="headerlink" title="二、计算机组成原理"></a>二、计算机组成原理</h1><ol><li><p><strong>RISC与CISC指令集</strong></p><p>从硬件角度来看CISC处理的是<strong>不等长指令集</strong>，RISC执行的是<strong>等长精简指令集</strong></p></li><li><p><strong>流水线技术</strong></p><p>流水线技术是一种将每条指令分解为多步，并让各步操作重叠，从而实现几条指令并行处理的技术。</p></li><li><p><strong>存储器层次结构</strong></p><p>随机访问存储器：</p><ol><li>SRAM（双稳态触发器存储、易失、速度快）</li><li>DRAM（栅极电容存储、易失、地址复用技术）</li></ol></li><li><p><strong>局部性原理</strong></p><ol><li><strong>时间局部性</strong>（Temporal Locality）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。程序循环、堆栈等是产生时间局部性的原因。</li><li><strong>空间局部性</strong>（Spatial Locality）：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。</li></ol></li><li><p><strong>虚拟存储器</strong>：为了给大的程序提供方便，使它们摆脱主存容量的限制，可以由操作系统把主存和辅存这两级存储系统管理起来，实现自动覆盖。</p></li><li><p><strong>中断</strong></p><ol><li>基本概念：执行现行程序时出现异常情况或特殊请求，CPU暂时中止转而去处理这些紧急情况，处理完毕后继续执行原程序</li><li>中断大概阶段：中断请求、中断判优、中断响应、中断处理和中断返回。</li><li>断点：断点是一个信号，它通知调试器，在某个特定点上暂时将程序执行挂起（进入中断状态）</li></ol></li></ol><hr><h1 id="三、操作系统"><a href="#三、操作系统" class="headerlink" title="三、操作系统"></a>三、操作系统</h1><ol><li><p><strong>进程</strong>：并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念。</p></li><li><p><strong>线程</strong>：是进程的一个执行单元，是进程内调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</p></li><li><p><strong>死锁</strong>：<br>死锁是指一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态</p><ol><li><strong>产生死锁的四个必要条件：</strong><ol><li>互斥条件：一个资源每次只能被一个进程使用。</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol></li><li><strong>避免死锁的方法：</strong>银行家算法</li></ol></li><li><p><strong>进程的三种状态</strong></p><ol><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源 </li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数 </li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li></ol></li><li><p><strong>页面置换算法</strong></p><ol><li>FIFO算法：淘汰最早调入的页面（队列思想）</li><li>OPT（MIN）：选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小（不可实现）</li><li>LRU（Least recently use）最近最少使用算法：根据使用时间到现在的长短来判断；</li><li>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</li></ol></li><li><p><strong>进程间的通信的几种方式</strong></p><ol><li>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li>信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li>消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</li></ol></li><li><p><strong>线程同步的方式</strong></p><ol><li>互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问</li><li>信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量</li><li>事件(信号) Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ol></li></ol><hr><h1 id="四、计算机网络"><a href="#四、计算机网络" class="headerlink" title="四、计算机网络"></a>四、计算机网络</h1><ol><li><strong>TCP/IP五层模型</strong><ol><li>物理层：<br>负责比特流的透明传输。</li><li>链路层：<br>负责传输网络层交下来的数据，有封装成帧、透明传输、差错检测三大问题。ARP、RARP协议</li><li>网络层:<br>负责为分组交换网上的不同主机提供通信服务。IP、ICMP、IGMP、RIP、OSPF</li><li>运输层：<br>负责向两个主机中进程之间的通信提供服务。TCP、UDP</li><li>应用层：<br>直接为用户的应用进程提供服务（例如电子邮件、文件传输和终端仿真）HTTP、FTP、TELNET</li></ol></li><li><strong>RIP协议</strong><br>原理：采用<strong>距离向量路由协议</strong> ，周期性的发送自己的全部的路由信息，进行路由更新时传递路由表</li><li><strong>OSPF协议</strong><br>原理：采用<strong>链路状态路由协议</strong>，周期性的发送链路状态信息，使得区域内所有路由器最终都能形成一个跟踪网络链路状态的链路状态数据库</li><li><strong>TCP 与 UDP 的区别</strong><ol><li>UDP是面向无连接的，不可靠的数据报服务；</li><li>TCP是面向连接的，可靠的字节流服务。</li></ol></li><li><strong>TCP 的可靠性如何保证？</strong><br>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</li><li><strong>路由设备与相关层</strong><ol><li>物理层 ：中继器（Repeater，也叫放大器），集线器。</li><li>数据链路层 ：网桥，交换机。</li><li>网络层 ：路由器。</li><li>网关 ：网络层以上的设备。</li></ol></li></ol><hr><h1 id="五、软件工程"><a href="#五、软件工程" class="headerlink" title="五、软件工程"></a>五、软件工程</h1><ol><li><strong>瀑布模型：</strong><br>特点：阶段间具有顺序性和依赖性<br>优点：有质量保证<br>缺点：开始需要把需求做到最全，需求变更麻烦</li><li><strong>螺旋模型</strong>：<br>特点：强调风险分析，适应于内部的大规模软件开发<br>优点：设计灵活、客户始终参与每个阶段的开发<br>缺点：开发周期长</li><li><strong>增量模型</strong><br>特点：将待开发的软件系统模块化和组件化<br>优点：人员分配灵活，刚开始不用投入大量人力资源<br>缺点：加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构</li><li><strong>快速原型模型</strong><br>特点：迅速建造一个可以运行的软件原型<br>优点：克服瀑布模型的缺点,减少由于软件需求不明确带来的开发风险<br>缺点：快速建立起来的系统结构加上连续的修改可能会导致产品质量低下</li><li><strong>喷泉模型</strong><br>特点：开发阶段可以交互进行<br>优点：提高开发效率，适合面向对象的软件开发过程<br>缺点：要求严格管理文档，不利于项目的管理</li><li><strong>软件生命周期</strong>：一个软件从提出开发要求开始直到该软件报废为止的整个时期。</li><li><strong>软件设计的基本原理</strong>：模块化、抽象、信息屏蔽、模块独立性</li><li><strong>面向对象的特征是</strong>：对象唯一性、分类性、继承性、多态性</li><li><strong>黑盒测试和白盒测试有何区别，黑盒测试有哪些常用方法：</strong>前者基于功能，后者基于结构；黑盒测试常用方法有：边界值、等价类、因果图、错误推测法等</li><li><strong>软件测试要经过的步骤是</strong>：单元测试→集成测试→确认测试→系统测试</li><li><strong>软件生命周期划分为哪几个阶段？</strong><ol><li>软件生命周期分为三个时期八个阶段：</li><li>软件定义：问题定义、可行性研究；</li><li>软件开发：需求分析、概要设计、详细设计、编码、测试；</li><li>软件运行：软件维护</li></ol></li><li><strong>简述三种面向对象模型的主要功能</strong>？<ol><li>对象模型：表示了静态的结构化的系统数据性质，描绘了系统的静态结构，从客观世界实体的对象关系角度来描绘对象。</li><li>动态模型：该模型描述了系统的控制结构，它表示了瞬间的、行为化的系统控制性质，它关心的是系统的控制及操作的执行顺序，它从对象的事件和状态的角度出发，表现了对象的交互行为。</li><li>功能模型：表示变化的系统“功能”性质，它指明系统应该“做什么”，因此功能模型更直接的反映了用户对目标系统的要求。</li></ol></li></ol><hr><h1 id="六、数据库"><a href="#六、数据库" class="headerlink" title="六、数据库"></a>六、数据库</h1><ol><li><p><strong>视图和表的区别</strong>：</p><ol><li>数据都是存储在表中的，而视图只是一个或多个表依照某个条件组合而成的结果集，一般来说你可以用update，insert，delete等sql语句修改表中的数据，而对视图只能进行select操作。</li></ol></li><li><p><strong>事务的ACID特性</strong>：</p><ol><li>原子性（<strong>A</strong>tomicity）<br>事务是一个不可再分割的工作单位</li><li>一致性（<strong>C</strong>onsistency）<br>执行一个事务前和后，数据库的完整性约束没有没有被破坏</li><li>隔离性（<strong>l</strong>solation）<br>多个事务并发时，每个事务应该是隔离的</li><li>持久性（<strong>D</strong>urability）<br>事务执行完成后，事务对数据库的更改便持久到了数据库中，这个更改是永久的</li></ol></li><li><p><strong>数据库的锁</strong></p><ol><li><strong>行级锁</strong>：是一种排他锁，防止其他事务修改此行</li><li><strong>表级锁</strong>：<ol><li>行共享 (ROW SHARE) – 禁止排他锁定表</li><li>行排他(ROW EXCLUSIVE) – 禁止使用排他锁和共享锁</li><li>共享锁(SHARE) - 锁定表，对记录只读不写，多个用户可以同时在同一个表上应用此锁</li><li>共享行排他(SHARE ROW EXCLUSIVE) – 比共享锁更多的限制，禁止使用共享锁及更高的锁</li><li>排他(EXCLUSIVE) – 限制最强的表锁，仅允许其他用户查询该表的行。禁止修改和锁定表。</li></ol></li></ol></li><li><p><strong>什么是存储过程？有哪些优缺点？</strong></p><p>存储过程是一些预编译的SQL语句，执行效率比较高，安全性高；开发调试复杂。</p></li><li><p><strong>索引是什么？有什么作用以及优缺点？</strong></p><p>索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构</p></li><li><p><strong>什么是事务？</strong></p><p>并发控制的基本单位，一个操作序列，一个不可分割的工作单位。</p></li><li><p><strong>数据库的乐观锁和悲观锁是什么</strong>？</p><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p></li><li><p><strong>简单说一说drop、delete与truncate的区别</strong></p><p>delete和truncate只删除表的数据不删除表的结构<br>速度,一般来说: drop&gt; truncate &gt;delete </p><p>delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;</p><p>如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. </p></li><li><p><strong>超键、候选键、主键、外键分别是什么？</strong></p><ol><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ol></li><li><p><strong>三个范式</strong></p><ol><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y。</li></ol></li></ol><hr><h1 id="七、编译原理"><a href="#七、编译原理" class="headerlink" title="七、编译原理"></a>七、编译原理</h1><ol><li><p><strong>编译过程四个阶段</strong>:</p><p>（.c）&gt;预处理（.i）&gt;编译（.s）&gt;汇编（.o）&gt;链接（.exe）</p><ol><li><p>预处理： 展开头文件/宏替换/去掉注释/条件编译（test.i, main.i）</p></li><li><p>编译： 检查语法，生成汇编（test.s  main.s）</p></li><li>汇编：  汇编代码转换机器码（test.o main.o）</li><li>链接：链接到一起生成可执行程序（a.out）</li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、数据结构（-算法）&quot;&gt;&lt;a href=&quot;#一、数据结构（-算法）&quot; class=&quot;headerlink&quot; title=&quot;一、数据结构（+算法）&quot;&gt;&lt;/a&gt;一、数据结构（+算法）&lt;/h1&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="复试笔记" scheme="https://hydrogensulfate.github.io/tags/%E5%A4%8D%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>WIN10/7 tensorflow-gpu+keras深度学习工具安装及测试</title>
    <link href="https://hydrogensulfate.github.io/2019/02/06/WIN10-7-tensorflow-gpu-keras%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E5%8F%8A%E6%B5%8B%E8%AF%95/"/>
    <id>https://hydrogensulfate.github.io/2019/02/06/WIN10-7-tensorflow-gpu-keras深度学习工具安装及测试/</id>
    <published>2019-02-06T05:45:55.000Z</published>
    <updated>2019-10-29T08:10:51.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="零-预备条件"><a href="#零-预备条件" class="headerlink" title="零.预备条件"></a>零.预备条件</h1><ol><li>个人硬件环境：E3-1231V3+GTX970（4G） </li><li>个人软件环境：WIN7 SP1 64位（WIN10同理）</li></ol><a id="more"></a><h1 id="一-安装Anaconda-Python3-7并配置Python3-6的环境和其下必要包"><a href="#一-安装Anaconda-Python3-7并配置Python3-6的环境和其下必要包" class="headerlink" title="一.安装Anaconda Python3.7并配置Python3.6的环境和其下必要包"></a>一.安装Anaconda Python3.7并配置Python3.6的环境和其下必要包</h1><p>主要是用这个东西似乎管理起来方便一丢丢…<br>官方下载链接：<a href="https://repo.anaconda.com/archive/Anaconda3-2018.12-Windows-x86_64.exe" target="_blank" rel="noopener">Anaconda 2018.12 for Windows Installer Python 3.7 version</a></p><ol><li>安装过程中把加入系统路劲的那个英文选项勾上。</li><li>打开Anaconda Python3.7点击Create，选择python 3.6，名字方便点起为py36<img src="https://img-blog.csdnimg.cn/20190205152546186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190205152852499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li>Create好后点击py36标签激活加载它，点击绿色箭头，选择open Terminal</li><li><p>在这个Terminal中安装keras、tensorflow-gpu、numpy（注意是gpu版本），安装命令如下（把pip换成conda应该也可以）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install keras</span><br><span class="line">pip install tensorflow-gpu</span><br><span class="line">pip install numpy</span><br></pre></td></tr></table></figure></li><li><p>安装完后用pip list查看安装安装情况<br> <img src="https://img-blog.csdnimg.cn/20190205153700548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 如果后期有提示什么version问题的，尽可能把这三个包括pip本身升级到最新版再试试。</p><h1 id="二-安装CUDA9-0和对应版本CUDNN并测试"><a href="#二-安装CUDA9-0和对应版本CUDNN并测试" class="headerlink" title="二.安装CUDA9.0和对应版本CUDNN并测试"></a>二.安装CUDA9.0和对应版本CUDNN并测试</h1><p>CUDNN的版本一定要对应CUDA，不然可能出问题。<br>下载地址：<br><a href="https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda_9.0.176_windows-exe" target="_blank" rel="noopener">CUDA 9.0</a><br><a href="https://developer.download.nvidia.cn/compute/machine-learning/cudnn/secure/v7.3.1/prod/9.0_2018927/cudnn-9.0-windows7-x64-v7.3.1.20.zip?6cjaQttNkv4eA3RleyN9sQ_3HoL7uSH5pmKSDkF6MaMyHT_g4OFsyR1CaIVo_FCOGYHfHJ-aJ9vyuEofhhn4iDYZ5ZahhHCSZ2s8AV9urWU1Az6PXKWvszfADJdnmeP9uH0CYLVjHonloRuIoYZYDTreC3MVYGMtYlu_AsbP2lpymJhB7EMz2wLFrdGeNo0MDX36vUUChtsvyOVkUZo_qlI" target="_blank" rel="noopener">CUDNN 7.3.1.20</a><br>有时候安装CUDA报错也许是vs的那个关联组件安装失败，在安装的时候选项选自定义，然后把vs的那个integration那一个东西取消安装就行（因为我用pycharm而不用vs）</p></li><li>按照网上教程把CUDNN三个文件夹下的内容分别复制到CUDA的对应三个文件夹下</li><li>设置好CUDA的环境变量里的路径，我按照网上的某个教程是这样的<br> <img src="https://img-blog.csdnimg.cn/20190205154627597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20190205154642406.png" alt="在这里插入图片描述"></li><li>测试cuda是否安装好及环境变量是否设置好<br> 在刚才的Terminal或者直接系统本身的cmd里输入nvcc —version，如果出现这样的提示，说明安装正常<br> <img src="https://img-blog.csdnimg.cn/20190205154839504.png" alt="在这里插入图片描述"><h1 id="三-安装Pycharm（社区免费版）并测试tensorflow-gpu代码"><a href="#三-安装Pycharm（社区免费版）并测试tensorflow-gpu代码" class="headerlink" title="三.安装Pycharm（社区免费版）并测试tensorflow-gpu代码"></a>三.安装Pycharm（社区免费版）并测试tensorflow-gpu代码</h1>下载地址：<a href="https://download.jetbrains.8686c.com/python/pycharm-community-2018.3.4.exe" target="_blank" rel="noopener">JetBrains PyCharm Community Edition 2018.3.4 x64</a></li><li>安装好之后新建项目，在项目里这样新建一个测试的代码文件<br> <img src="https://img-blog.csdnimg.cn/20190205155255329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><p>然后把以下代码复制进去</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">hello = tf.constant(<span class="string">'Hello, TensorFlow!'</span>)</span><br><span class="line">sess = tf.Session()</span><br><span class="line">print(sess.run(hello))</span><br></pre></td></tr></table></figure></li><li><p>此时不能直接运行，点击界面的File-Settings-Project:你的包名-Project interpreter-<br> <img src="https://img-blog.csdnimg.cn/20190205155452304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 点击小齿轮-选择add<img src="https://img-blog.csdnimg.cn/20190205155631196.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/2019020515563930.png" alt="在这里插入图片描述"><br> 在跳出来的界面中选择Existing environment<br> <img src="https://img-blog.csdnimg.cn/20190205155843769.png" alt="在这里插入图片描述"><br> 选择一开始安装的py36环境对应的文件夹下的python.exe，我的路径：<img src="https://img-blog.csdnimg.cn/20190205155928401.png" alt="在这里插入图片描述"><br> 然后等待一下等upgrade和indexing完毕之后，在代码文件这里按ctrl+shfit+F10运行文件。如果跳出下面的提示，则成功用到了tensorflow-gpu<br> <img src="https://img-blog.csdnimg.cn/20190205160909178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E4ODc3MDIwMg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> <strong>另外如果出现了numpy的版本什么0xb和0xc的报错，则去<code>anaconda\envs\py36\Lib\site-packages</code>路径下把与numpy有关的三个包文件夹删掉，然后重新在py36的Terminal里安装numpy<code>pip install numpy</code></strong></p></li></ol><h1 id="四-小结"><a href="#四-小结" class="headerlink" title="四.小结"></a>四.小结</h1><p>至此应该可以算是入门级基本运用了tensorflow-gpu了，后面再来的训练上和输出展示啥的要的包比如opencv，matplot什么的自己用命令或者anaconda界面里安装一下，缺啥装啥就行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;零-预备条件&quot;&gt;&lt;a href=&quot;#零-预备条件&quot; class=&quot;headerlink&quot; title=&quot;零.预备条件&quot;&gt;&lt;/a&gt;零.预备条件&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;个人硬件环境：E3-1231V3+GTX970（4G） &lt;/li&gt;
&lt;li&gt;个人软件环境：WIN7 SP1 64位（WIN10同理）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hydrogensulfate.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://hydrogensulfate.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="tensorflow" scheme="https://hydrogensulfate.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>CF #485 Div.2题解</title>
    <link href="https://hydrogensulfate.github.io/2018/05/31/CF-485-Div-2%E9%A2%98%E8%A7%A3/"/>
    <id>https://hydrogensulfate.github.io/2018/05/31/CF-485-Div-2题解/</id>
    <published>2018-05-31T15:56:41.000Z</published>
    <updated>2018-06-11T07:09:01.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Infinity-Gauntlet"><a href="#A-Infinity-Gauntlet" class="headerlink" title="A.Infinity Gauntlet"></a><a href="http://codeforces.com/contest/987/problem/A" target="_blank" rel="noopener">A.Infinity Gauntlet</a></h1><p>水题。</p><a id="more"></a><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[<span class="string">"purple"</span>] = <span class="string">"Power"</span>;</span><br><span class="line">    st[<span class="string">"green"</span>] = <span class="string">"Time"</span>;</span><br><span class="line">    st[<span class="string">"blue"</span>] = <span class="string">"Space"</span>;</span><br><span class="line">    st[<span class="string">"orange"</span>] = <span class="string">"Soul"</span>;</span><br><span class="line">    st[<span class="string">"red"</span>] = <span class="string">"Reality"</span>;</span><br><span class="line">    st[<span class="string">"yellow"</span>] = <span class="string">"Mind"</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        st[s] = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sz =  <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : st)</span><br><span class="line">        <span class="keyword">if</span> (x.second != <span class="string">""</span>)</span><br><span class="line">            ++sz;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : st)</span><br><span class="line">        <span class="keyword">if</span> (x.second != <span class="string">""</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, x.second.c_str());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-High-School-Become-Human"><a href="#B-High-School-Become-Human" class="headerlink" title="B.High School: Become Human"></a><a href="http://codeforces.com/contest/987/problem/B" target="_blank" rel="noopener">B.High School: Become Human</a></h1><p>给定整数$x、y$，求$x^y$和$y^x$的大小关系，首先肯定用<code>log</code>函数取一下对数，然后再设稍微小一点的<code>eps</code>比较一下即可。这里注意用<code>long double</code>提高一下精度，<code>double</code>会出现一些奇奇怪怪的问题。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LF;</span><br><span class="line"><span class="keyword">const</span> lf eps = <span class="number">1e-15</span>;</span><br><span class="line">LF a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        LF xx = b * <span class="built_in">log10</span>(a), yy = a * <span class="built_in">log10</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (xx == yy)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(xx &gt; yy ? <span class="string">"&gt;"</span> : <span class="string">"&lt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Three-displays"><a href="#C-Three-displays" class="headerlink" title="C.Three displays"></a><a href="http://codeforces.com/contest/987/problem/C" target="_blank" rel="noopener">C.Three displays</a></h1><p>题意就是给定长度为$n$的数列$S$和$C$，求三个数满足$i \lt j \lt k，S_i \lt S_j \lt S_k$的情况下$C_i + C_j + C_k$的最小值，对于这种三元之间的关系问题可以考虑枚举中间那个数来优化复杂度至$O(n ^ 2)$。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3010</span>;</span><br><span class="line"><span class="keyword">int</span> n, s[N];</span><br><span class="line">ll c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sf(s[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sfl(c[i]);</span><br><span class="line">    ll inf = <span class="number">1l</span>l &lt;&lt; <span class="number">60</span>;</span><br><span class="line">    ll ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        ll l = inf, r = inf;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &lt; s[i])</span><br><span class="line">                l = min(l, c[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[j] &gt; s[i])</span><br><span class="line">                r = min(r, c[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != inf &amp;&amp; r != inf)</span><br><span class="line">            ans = min(ans, l + r + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans == inf ? <span class="number">-1l</span>l : ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Fair"><a href="#D-Fair" class="headerlink" title="D.Fair"></a><a href="http://codeforces.com/contest/987/problem/D" target="_blank" rel="noopener">D.Fair</a></h1><p>题意就是给定$n$个城市和$m$条边权为$1$的无向边，有$k$种商品，每个城市一开始已有一种商品$a_i$，求至少个其他城市的人带自己城市的商品到第$i$个城市，使得城市$i$收集到至少$s$种商品的最小花费。</p><p>由于商品的种类数最多$100$个，因此可以考虑已商品为点，枚举商品时把具有当前商品的城市的花费设为$0$，其他为$ +\infty$，做$k$次多源<code>BFS</code>，即用$dis[i][j]$表示运送第$j$种商品到第$i$个城市的最小花费。然后每个$dis[i]$取前$s$小个花费相加即可。</p><p><strong>这里有个小优化技巧，求数组的前k大可以用<code>nth_element(begin, begin + k, end)</code>这个函数，而不用每次都<code>sort</code></strong></p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, s, a[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _to, <span class="keyword">int</span> _nxt): to(_to), nxt(_nxt) &#123;&#125;</span><br><span class="line">&#125; E[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(head, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[tot] = edge(t, head[s]);</span><br><span class="line">    head[s] = tot++;</span><br><span class="line">    E[tot] = edge(s, head[t]);</span><br><span class="line">    head[t] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">    clr(d, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] == c)</span><br><span class="line">            d[i] = <span class="number">0</span>, Q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = head[u]; ~i; i = E[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> &amp;v = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                Q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        dis[i].pb(d[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> i, x, y;</span><br><span class="line">    sf(n), sf(m), sf(k), sf(s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sf(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sf(x), sf(y);</span><br><span class="line">        add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">        bfs(i);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;    </span><br><span class="line">        nth_element(dis[i].begin(), dis[i].begin() + s, dis[i].end());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, accumulate(dis[i].begin(), dis[i].begin() + s, <span class="number">0</span>), <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Petr-and-Permutations"><a href="#E-Petr-and-Permutations" class="headerlink" title="E.Petr and Permutations"></a><a href="http://codeforces.com/contest/987/problem/E" target="_blank" rel="noopener">E.Petr and Permutations</a></h1><p>题意就是存在一个长度为$n$的初始排列，<code>Petr</code>会对一个排列做$3n$次两两元素随机交换，而<code>Um_nik</code>会做$7n + 1$次，现给定排列后的结果，求是<code>Petr</code>做的还是<code>Um_nik</code>做的。</p><p>由于题目是结果唯一的，那就是符合所有特殊情况，考虑一种特殊情况——他们两个人运气够好，使得相邻的两次交换总是互相抵消，而交换元素位置会使得逆序数的奇偶发生改变（一开始的初始序列逆序数为$0$），逆序数嘛<code>BIT</code>搞搞，注意开<code>long long</code>就好。</p><p>那么只要看交换次数是奇数还是偶数就行了。因此分类讨论一下</p><ol><li>当$n$为奇数时，$3n$为奇数，$7n + 1$为偶数，如果逆序数是奇数则肯定是<code>Petr</code>，否则为<code>Um_nik</code></li><li>当$n$为偶数时，$3n$为偶数，$7n + 1$为奇数，如果逆序数是奇数则肯定是<code>Um_nik</code>，否则为<code>Petr</code></li></ol><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, i, a[N], T[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        T[k] += v;</span><br><span class="line">        k += (k &amp; -k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        w += T[k];</span><br><span class="line">        k -= (k &amp; -k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ll w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sf(a[i]);</span><br><span class="line">        w += ((ll)(i - <span class="number">1</span>) - sum(a[i]));</span><br><span class="line">        add(a[i], <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">puts</span>(w &amp; <span class="number">1</span> ? <span class="string">"Petr"</span> : <span class="string">"Um_nik"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(w &amp; <span class="number">1</span> ? <span class="string">"Um_nik"</span> : <span class="string">"Petr"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-AND-Graph"><a href="#F-AND-Graph" class="headerlink" title="F.AND Graph"></a><a href="http://codeforces.com/contest/987/problem/F" target="_blank" rel="noopener">F.AND Graph</a></h1><p>题意就是给你$n、m$，表示有$m$个数大小在$[0, 2 ^ n - 1]$之间，如果有两个数$a \&amp; b = 0$，那么这两个数之间有一条无向边，求这$m$个数最终分成几个连通块。<br>自己<code>YY</code>了很久没调出来滚去看题解了。</p><ol><li>显然一个数本身可以和其补码相连；</li><li>补码的任意为$0$的位置可以改为$1$，因为这样再做一次补码后该位会变回$0$，不会改变按位与为$0$的结果；</li><li>补码可以随时和补码的补码相连。<br>这样<code>DFS</code>一下就可以了。</li></ol><h2 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sfl(x) scanf(<span class="meta-string">"%lld"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1</span> &lt;&lt; <span class="number">22</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], vis[N][<span class="number">2</span>], mx, sz, ins[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span> - x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[u][flag])</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    vis[u][flag] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (u &gt;&gt; i &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            dfs(u | (<span class="number">1</span> &lt;&lt; i), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ins[rs(u)])</span><br><span class="line">            dfs(rs(u), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dfs(u, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sf(n), sf(m);</span><br><span class="line">    mx = <span class="number">1</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        sf(a[i]), ins[a[i]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[a[i]][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++sz;</span><br><span class="line">            dfs(a[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sz);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Infinity-Gauntlet&quot;&gt;&lt;a href=&quot;#A-Infinity-Gauntlet&quot; class=&quot;headerlink&quot; title=&quot;A.Infinity Gauntlet&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/contest/987/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A.Infinity Gauntlet&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;水题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="比赛" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="BFS" scheme="https://hydrogensulfate.github.io/tags/BFS/"/>
    
      <category term="树状数组" scheme="https://hydrogensulfate.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="DFS" scheme="https://hydrogensulfate.github.io/tags/DFS/"/>
    
      <category term="暴力" scheme="https://hydrogensulfate.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>Wannafly挑战赛16 AB序列（三分求离散凹函数极值）</title>
    <link href="https://hydrogensulfate.github.io/2018/05/26/Wannafly%E6%8C%91%E6%88%98%E8%B5%9B16-AB%E5%BA%8F%E5%88%97/"/>
    <id>https://hydrogensulfate.github.io/2018/05/26/Wannafly挑战赛16-AB序列/</id>
    <published>2018-05-25T16:22:04.000Z</published>
    <updated>2018-05-26T08:02:54.013Z</updated>
    
    <content type="html"><![CDATA[<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format: %lld</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给长度为$n$的序列$A$，长度为$m$的序列$B$。可以给A序列里每个元素加上$x$且$B$序列里每个元素减去$x$ ($x$可以是负数），问$\sum{|A_i|}+\sum{B_i}+|x|$的最小值</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一行两个整数分别表示n,m</span><br><span class="line">接下来一行n个整数表示序列A</span><br><span class="line">接下来一行m个整数表示序列B</span><br></pre></td></tr></table></figure><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示答案</span><br></pre></td></tr></table></figure><p> 示例1 </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">-8</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">10</span></span><br><span class="line"><span class="number">5</span> <span class="number">-5</span> <span class="number">-4</span> <span class="number">-9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">57</span></span><br></pre></td></tr></table></figure><p>备注:</p><p>$1\le n,m\le 10^5$<br>序列中的数为绝对值不超过$10^9$的整数</p><p>题目链接：<a href="https://www.nowcoder.com/acm/contest/113/B" target="_blank" rel="noopener">Wannafly挑战赛16 AB序列</a></p><p>学习并记录一下<strong>整型</strong>三分的一种基本姿势，用$midl$表示$l…r$中的中间位置，用$midr$表示$midl…r$中的中间位置，然后看哪一端更符合要求，最后注意还要特判最后留下的$l$和$r$到底哪个最优即可。</p><p><img src="https://s1.ax1x.com/2018/05/26/Cf2wDS.png" alt="Cf2wDS.png"></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        w += llabs(a[i] + x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        w += llabs(b[i] - x);</span><br><span class="line">    <span class="keyword">return</span> w + llabs(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    sf(n), sf(m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, b + i);</span><br><span class="line">    ll l = <span class="number">-1e9</span> - <span class="number">10</span>, r = <span class="number">1e9</span> + <span class="number">10</span>, midl, midr;</span><br><span class="line">    <span class="keyword">while</span> (l + <span class="number">1</span> &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        midl = (l + r) &gt;&gt; <span class="number">1</span>, midr = (midl + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (calc(midl) &lt;= calc(midr))</span><br><span class="line">            r = midr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = midl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(calc(l), calc(r)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="三分" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/%E4%B8%89%E5%88%86/"/>
    
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="三分" scheme="https://hydrogensulfate.github.io/tags/%E4%B8%89%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CF Educational #44 A B C D E F</title>
    <link href="https://hydrogensulfate.github.io/2018/05/23/CF-Educational-44-A-B-C-D-E-F/"/>
    <id>https://hydrogensulfate.github.io/2018/05/23/CF-Educational-44-A-B-C-D-E-F/</id>
    <published>2018-05-23T14:34:25.000Z</published>
    <updated>2018-05-25T03:31:14.339Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Chess-Placing"><a href="#A-Chess-Placing" class="headerlink" title="A.Chess Placing"></a><a href="http://codeforces.com/contest/985/problem/A" target="_blank" rel="noopener">A.Chess Placing</a></h1><p>题意就是给你$n$个黑白相间的位置，其中放$n/2$个棋子，求把所有棋子从初始位置摆放成在全白或者全黑位置最少的移动次数。</p><a id="more"></a><p>由于棋子个数固定，显然是要么全放白要么全放黑，<code>sort</code>一遍暴力试一下两种情况取最小值即可。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>, pos = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        w += <span class="built_in">abs</span>(a[i] - pos);</span><br><span class="line">        pos += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = min(ans, w);</span><br><span class="line">    w = <span class="number">0</span>, pos = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        w += <span class="built_in">abs</span>(a[i] - pos);</span><br><span class="line">        pos += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = min(ans, w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Switches-and-Lamps"><a href="#B-Switches-and-Lamps" class="headerlink" title="B.Switches and Lamps"></a><a href="http://codeforces.com/contest/985/problem/B" target="_blank" rel="noopener">B.Switches and Lamps</a></h1><p>题意就是给你$n$个开关，各自控制$m$盏灯中某些灯，问是否能不按某<strong>一个</strong>开关使得按下剩下的开关后所有的灯都会打开（灯一开始全部关闭且打开后不会再关闭）。</p><p>暴力检查一下是否剩余的开关能控制到所有$m$盏灯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2005</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> sz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    sf(n), sf(m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s[i]);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'1'</span>)</span><br><span class="line">                ++sz[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ig = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            <span class="keyword">if</span> (s[i][j] == <span class="string">'1'</span>)</span><br><span class="line">                --sz[j];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (sz[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ig = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ig)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'1'</span>)</span><br><span class="line">                    ++sz[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Liebig’s-Barrels"><a href="#C-Liebig’s-Barrels" class="headerlink" title="C.Liebig’s Barrels"></a><a href="http://codeforces.com/contest/985/problem/C" target="_blank" rel="noopener">C.Liebig’s Barrels</a></h1><p>题意就是给你$n\times k$个木条，做$n$个水桶，每一个水桶的体积$v_i$为选择$k$条木条的最小值，且木桶的体积最大最小之差不能超过$l$，求最大的体积总和。</p><p>首先从大到小<code>sort</code>一下，最坏情况下用$a[nk-n+1]…a[nk]​$分别作为第$i​$个木桶的最小值，如果差值大于$l​$说明无法构成。</p><p>否则贪心地从大到小地记录一下当前可用的木条数$res$，如果$res&gt;=k$且当前的$a[i]-a[nk]&lt;=l$，那么就可以把当前的$k$根木条拿去做桶且体积刚好是$a[i]$。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cpx;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="keyword">int</span> n, k, m;</span><br><span class="line">ll l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; l)</span><br><span class="line">    &#123;</span><br><span class="line">        m = n * k;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, a + i);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + m, greater&lt;ll&gt;());</span><br><span class="line">        <span class="keyword">if</span> (a[m - n + <span class="number">1</span>] - a[m] &gt; l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"0"</span>), <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ll ans = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">if</span> (a[i] - a[m] &lt;= l &amp;&amp; res &gt;= k)</span><br><span class="line">            &#123;</span><br><span class="line">                res -= k;</span><br><span class="line">                ans += a[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, !res ? ans : <span class="number">0l</span>l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Sand-Fortress"><a href="#D-Sand-Fortress" class="headerlink" title="D.Sand Fortress"></a><a href="http://codeforces.com/contest/985/problem/D" target="_blank" rel="noopener">D.Sand Fortress</a></h1><p>题意就是给你$n$个沙袋和第一堆堆积高度的最大值$h$，求相邻堆积高度差不超过$1$的前提下最少要堆几堆。</p><p>首先可以肯定用贪心地方法去堆，由于最后要递减到$0$，因此后端一定是从最高高度$H$等差数列地下降，然后如果$H$大于$h$就还要算上左边堆砌到$H$的代价，也是一个等差数列求和。这样子二分出一个最高高度$H$，那么答案用$H$算就行了。这里有个细节就是如果右边堆砌到$H(\gt h)$，那么左边只需要堆砌到$H-1$就能接上了，不需要到$H$。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line">ll n, h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(ll H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll t = n;</span><br><span class="line">    t -= (H * (H + <span class="number">1l</span>l)) / <span class="number">2l</span>l;</span><br><span class="line">    <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(H &gt; h)</span><br><span class="line">        t -= (h + H - <span class="number">1</span>) * (H - h) / <span class="number">2l</span>l;</span><br><span class="line">    <span class="keyword">if</span>(t &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h)</span><br><span class="line">    &#123;</span><br><span class="line">        ll l = <span class="number">1</span>, r = <span class="number">2e9</span> + <span class="number">10l</span>l, one = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            ll mid = MID(l, r);</span><br><span class="line">            <span class="keyword">if</span>(check(mid))</span><br><span class="line">            &#123;</span><br><span class="line">                one = mid;</span><br><span class="line">                l = mid + <span class="number">1l</span>l;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1l</span>l;</span><br><span class="line">        &#125;</span><br><span class="line">        n -= one * (one + <span class="number">1l</span>l) / <span class="number">2l</span>l;</span><br><span class="line">        ll day = one;</span><br><span class="line">        <span class="keyword">if</span>(one &gt; h)</span><br><span class="line">        &#123;</span><br><span class="line">            day += one - h + <span class="number">1l</span>l;</span><br><span class="line">            n -= ((h + one) * (one - h + <span class="number">1l</span>l) / <span class="number">2l</span>l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, day + (ll)<span class="built_in">ceil</span>(<span class="number">1.0</span> * n / one));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-Pencils-and-Boxes"><a href="#E-Pencils-and-Boxes" class="headerlink" title="E.Pencils and Boxes"></a><a href="http://codeforces.com/contest/985/problem/E" target="_blank" rel="noopener">E.Pencils and Boxes</a></h1><p>给你$n$支笔和对应长度，将这些笔分成许多组，每一组的大小要大于等于$k$，且同组内长度差的最大值不能超过$d$，求是否存在这种方案。</p><p>按照题解说的有个结论，如果将笔按长度有序排好那么如果方案存在，那么用连续的区间划分一定也可以作为方案，那么用$dp[i]$表示前$i$支笔是否能成功分配，那么有$dp[i] = dp[i] \;|\; dp[j]$，其中$a[i]-a[j+1]&lt;=d\&amp;\&amp;i-j \ge k$，那么就把$a$排序之后用指针实时调整到符合的位置，然后树状数组更新维护一下即可。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, k, d;</span><br><span class="line"><span class="keyword">int</span> dp[N], T[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++x;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        T[x] += v;</span><br><span class="line">        x += (x &amp; -x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++x;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        w += T[x];</span><br><span class="line">        x -= (x &amp; -x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">S</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> sum(r) - sum(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(dp, <span class="number">0</span>);</span><br><span class="line">    clr(T, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; d)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            sf(a[i]);</span><br><span class="line">        sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        add(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[i] - a[j] &gt; d)</span><br><span class="line">                ++j;</span><br><span class="line">            <span class="keyword">if</span> (S(j - <span class="number">1</span>, i - k))</span><br><span class="line">                dp[i] = <span class="number">1</span>, add(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(dp[n] ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Isomorphic-Strings"><a href="#F-Isomorphic-Strings" class="headerlink" title="F.Isomorphic Strings"></a><a href="http://codeforces.com/contest/985/problem/F" target="_blank" rel="noopener">F.Isomorphic Strings</a></h1><p>题意就是给你一个长度为$n$的字符串$s$和$m$个询问，问你某两个子串$S[x…x+d-1]$和$S[y…y+d-1]$是否是同构的，同构的意思就是把字符重新一一映射（置换）一下可以互相变成对方。</p><p>由于题解看不太懂，还是用别人的想法实现的，其实实现挺简单的，首先考虑如何判断字符串的同构，可以记录字符串中各个字母的出现位置，然后如果$s1$中的字符$a$和$s2$中的字符$b$出现位置集合一样，那么就可以将$a$映射到$b$，那么如果有多个字母就每个都验证一下，是否各自出现位置可以一一对应起来，那如何快速得到子串某个字母的出现位置集合信息呢？可以用$H[i][j]$表示长度为$i$的字符串字符$j$的目前所有出现位置的位置的哈希值，如果$S[i]==j$那么该位权值就是$1$否则就是$0$，这样每次把两个串的$26$个字母的位置集合哈希值都拿出来排个序看看是否可以一一对应即可。这题数据卡<code>ull</code>的自然溢出会<code>WA16</code>，<del>还是某个质数好用233333</del></p><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">19260817l</span>l;</span><br><span class="line"><span class="keyword">const</span> ll bas = <span class="number">1e9</span> + <span class="number">9l</span>l;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line">ll pre[N], H[N][<span class="number">26</span>], v[<span class="number">2</span>][<span class="number">26</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v[<span class="number">0</span>][i] = (H[x + d - <span class="number">1</span>][i] - H[x - <span class="number">1</span>][i] * pre[d]) % mod;</span><br><span class="line">        <span class="keyword">if</span>(v[<span class="number">0</span>][i] &lt; <span class="number">0</span>)</span><br><span class="line">            v[<span class="number">0</span>][i] += mod;</span><br><span class="line"></span><br><span class="line">        v[<span class="number">1</span>][i] = (H[y + d - <span class="number">1</span>][i] - H[y - <span class="number">1</span>][i] * pre[d]) % mod;</span><br><span class="line">        <span class="keyword">if</span>(v[<span class="number">1</span>][i] &lt; <span class="number">0</span>)</span><br><span class="line">            v[<span class="number">1</span>][i] += mod;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v[<span class="number">0</span>], v[<span class="number">0</span>] + <span class="number">26</span>);</span><br><span class="line">    sort(v[<span class="number">1</span>], v[<span class="number">1</span>] + <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span>(v[<span class="number">0</span>][i] != v[<span class="number">1</span>][i])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1l</span>l;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] * bas % mod;</span><br><span class="line">    sf(n), sf(m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            H[i][j] = (H[i - <span class="number">1</span>][j] * bas + (s[i] == j + <span class="string">'a'</span> ? <span class="number">1l</span>l : <span class="number">0l</span>l)) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;d);</span><br><span class="line">        <span class="built_in">puts</span>(check(x, y, d) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Chess-Placing&quot;&gt;&lt;a href=&quot;#A-Chess-Placing&quot; class=&quot;headerlink&quot; title=&quot;A.Chess Placing&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/contest/985/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A.Chess Placing&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题意就是给你$n$个黑白相间的位置，其中放$n/2$个棋子，求把所有棋子从初始位置摆放成在全白或者全黑位置最少的移动次数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="比赛" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="树状数组" scheme="https://hydrogensulfate.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="DP" scheme="https://hydrogensulfate.github.io/tags/DP/"/>
    
      <category term="哈希" scheme="https://hydrogensulfate.github.io/tags/%E5%93%88%E5%B8%8C/"/>
    
      <category term="二分" scheme="https://hydrogensulfate.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="暴力" scheme="https://hydrogensulfate.github.io/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>CF #484 Div.2 A B C D</title>
    <link href="https://hydrogensulfate.github.io/2018/05/20/CF-484-Div-2-A-B-C-D/"/>
    <id>https://hydrogensulfate.github.io/2018/05/20/CF-484-Div-2-A-B-C-D/</id>
    <published>2018-05-20T15:16:57.000Z</published>
    <updated>2018-05-20T16:35:52.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Row"><a href="#A-Row" class="headerlink" title="A.Row"></a><a href="http://codeforces.com/contest/982/problem/A" target="_blank" rel="noopener">A.Row</a></h1><p>题意就是给你$n$个$01$串，问你是否已经存在两个人相邻的$1$或者可以使某些位置的$0$变成$1$且不出现相邻的$1$，虽是水题实际上有点坑，注意下两边的特判就行。<br><a id="more"></a></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%s"</span>, &amp;n, s + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(s[<span class="number">1</span>] == <span class="string">'1'</span> ? <span class="string">"Yes"</span> : <span class="string">"No"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'1'</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">'1'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= n &amp;&amp; s[i] == <span class="string">'0'</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n - <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= n &amp;&amp; s[i] == <span class="string">'0'</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; i + <span class="number">1</span> &lt;= n &amp;&amp; s[i] == <span class="string">'0'</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">'0'</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">'0'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Bus-of-Characters"><a href="#B-Bus-of-Characters" class="headerlink" title="B.Bus of Characters"></a><a href="http://codeforces.com/contest/982/problem/B" target="_blank" rel="noopener">B.Bus of Characters</a></h1><p>题意就是$n$个内向和外向的人先后上公交车，按照一定的规则寻找他们要的座位，输出每个人所在座位的编号。</p><p>显然用堆模拟一下就就行了<code>STL</code>水题。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line">priority_queue&lt;pii&gt;in, ex;</span><br><span class="line"><span class="keyword">int</span> w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sf(w[i]);</span><br><span class="line">        in.push(&#123; -w[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pii a = in.top();</span><br><span class="line">            in.pop();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, a.second);</span><br><span class="line">            ex.push(&#123; -a.first, a.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pii a = ex.top();</span><br><span class="line">            ex.pop();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, a.second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Cut-‘em-all"><a href="#C-Cut-‘em-all" class="headerlink" title="C.Cut ‘em all!"></a><a href="http://codeforces.com/contest/982/problem/C" target="_blank" rel="noopener">C.Cut ‘em all!</a></h1><p>题意就是给你$n$个点的树，求删掉尽量多的边使得剩下的连通块点数全为偶数。输出最多删掉的边数。</p><p>显然如果$n$为偶数则一定可以，奇数一定不行（因为不管怎么分总有至少一个连通块会是奇数个点）。然后对这棵树<code>DFS</code>一次统计一下每颗子树的点数，如果子树$v$的大小为偶数则将当前结点$u$连向$v$的边删掉，断开即可。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;E[N];</span><br><span class="line"><span class="keyword">int</span> sz[N], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : E[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(v, u);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            <span class="keyword">if</span> (sz[v] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, a, b;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sf(a), sf(b);</span><br><span class="line">        E[a].pb(b);</span><br><span class="line">        E[b].pb(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Shark"><a href="#D-Shark" class="headerlink" title="D.Shark"></a><a href="http://codeforces.com/contest/982/problem/D" target="_blank" rel="noopener">D.Shark</a></h1><p>题意就是给你$n$天鲨鱼的前进距离$d_1…d_n$，规定如果某一天前进的距离$d_i \lt k$，那么这天相当于在原地，否则相当于移动到了新的地方，求在移动到新地方的次数最多且在每段在原地的天数均相同的前提下最小的$k$。</p><p>补题的时候题解是俄文的看不懂，别人的代码更看不懂系列，只知道排序+并查集做，在纸上模拟了好一会儿终于想通补掉了。</p><p>首先先对移动距离排序，然后遍历这些移动距离，遍历的时候假设$1…i$天是在原地的，那么此时最小的$k’$应是$d_i+1$，然后过程中用并查集维护哪些天可以连成连续的一段和，用集合大小维护段的大小，再用一个数组维护集合大小的出现次数，由于条件是<strong>每段在原地的天数均相同</strong>，那么只能是集合大小均相同的时候才能更新答案$k$，再用一个变量维护不同集合大小的个数即可。遍历过程模拟把当前天激活，并看下左右相邻的日子是否可以合并过去变成连续的一段。中间更新下那几个数组就行了。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> pre[N], sz[N], cnt[N], n, lencnt, dx, one;</span><br><span class="line">pii a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    clr(pre, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[n] == <span class="number">-1</span> ? n : pre[n] = fd(pre[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = fd(a), b = fd(b);</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[b] = a;</span><br><span class="line">        sz[a] += sz[b];</span><br><span class="line">        sz[b] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &lt;= n &amp;&amp; sz[fd(v)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[sz[fd(v)]] == <span class="number">0</span>)</span><br><span class="line">            --lencnt;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[sz[x]] == <span class="number">0</span>)</span><br><span class="line">            --lencnt;</span><br><span class="line">        mg(x, v);</span><br><span class="line">        <span class="keyword">if</span> (++cnt[sz[fd(v)]] == <span class="number">1</span>)</span><br><span class="line">            ++lencnt;</span><br><span class="line">    &#125;</span><br><span class="line">    v = x - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">1</span> &amp;&amp; sz[fd(v)])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[sz[fd(v)]] == <span class="number">0</span>)</span><br><span class="line">            --lencnt;</span><br><span class="line">        <span class="keyword">if</span> (--cnt[sz[fd(x)]] == <span class="number">0</span>)</span><br><span class="line">            --lencnt;</span><br><span class="line">        mg(x, v);</span><br><span class="line">        <span class="keyword">if</span> (++cnt[sz[fd(v)]] == <span class="number">1</span>)</span><br><span class="line">            ++lencnt;</span><br><span class="line">    &#125;</span><br><span class="line">    one = cnt[sz[fd(x)]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    init();</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sf(a[i].first);</span><br><span class="line">        a[i].second = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sz[a[i].second] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (++cnt[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            ++lencnt;</span><br><span class="line">        check(a[i].second);</span><br><span class="line">        <span class="keyword">if</span> (lencnt == <span class="number">1</span> &amp;&amp; one &gt; dx)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = a[i].first + <span class="number">1</span>;</span><br><span class="line">            dx = one;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Row&quot;&gt;&lt;a href=&quot;#A-Row&quot; class=&quot;headerlink&quot; title=&quot;A.Row&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/contest/982/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A.Row&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题意就是给你$n$个$01$串，问你是否已经存在两个人相邻的$1$或者可以使某些位置的$0$变成$1$且不出现相邻的$1$，虽是水题实际上有点坑，注意下两边的特判就行。&lt;br&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="比赛" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="STL" scheme="https://hydrogensulfate.github.io/tags/STL/"/>
    
      <category term="DFS" scheme="https://hydrogensulfate.github.io/tags/DFS/"/>
    
      <category term="并查集" scheme="https://hydrogensulfate.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>“浪潮杯”第九届山东省ACM大学生程序设计竞赛重现赛 B Bullet（二分+最大流）</title>
    <link href="https://hydrogensulfate.github.io/2018/05/19/%E6%B5%AA%E6%BD%AE%E6%9D%AF%E7%AC%AC%E4%B9%9D%E5%B1%8A%E5%B1%B1%E4%B8%9C%E7%9C%81ACM%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AB%9E%E8%B5%9B%E9%87%8D%E7%8E%B0%E8%B5%9B-B-Bullet/"/>
    <id>https://hydrogensulfate.github.io/2018/05/19/浪潮杯第九届山东省ACM大学生程序设计竞赛重现赛-B-Bullet/</id>
    <published>2018-05-19T15:50:25.000Z</published>
    <updated>2018-05-20T15:19:00.085Z</updated>
    
    <content type="html"><![CDATA[<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 65536K，其他语言131072K<br> 64bit IO Format: %lld</p><a id="more"></a><p>题目描述</p><p>In GGO, a world dominated by gun and steel, players are fighting for the honor of being the strongest gunmen. Player Shino is a sniper, and her aimed shot kills one monster at a time. Now she is in an n*n map, and there are monsters in some grids. Each monster has an experience. As a master, however, Shino has a strange self-restrain. She would kill at most one monster in a column, and also at most one in a row. Now she wants to know how to get max experience, under the premise of killing as many monsters as possible. </p><p>输入描述</p><p>The first line contains an integer $n$.<br>$n&lt;=500$<br>Then $n$ lines follow. In each line there are $n$integers, and $A_{ij}$ represents the experience of the monster at grid $(i,j)$.<br> If $A_{ij}=0$, there is no monster at grid $(i,j)$.<br>The experience is the minimal experience of all the monster which are killed.</p><p>It guaranteed that the maximum of the experience of the monster is not larger than $10^9$</p><p>输出描述</p><p>One integer, the value of max experience.</p><p>示例1</p><p>输入</p><p>2<br>2 0<br>1 8</p><p>输出</p><p>2</p><p>题目链接：<a href="https://www.nowcoder.com/acm/contest/123/B" target="_blank" rel="noopener">B.Bullet</a></p><p>退役之后图论没怎么做了，只记得最短路了23333，实际是个简单题，很显然的网络流，考虑一行一列最多只能放一个，因此把行和列拿出来当做点，设源点为$S$，汇点为$T$，先把最低经验值设为$1$，跑一遍最大流得到最坏情况下的最多杀怪数，然后二分最小的经验值，每次选出大于等于当前假设经验值的怪物，重新建图跑最大流。</p><p>建图如下：</p><ol><li>对所有行建边：$(S,i,\infty)$</li><li>对所有列建边：$(j+n,T,\infty)$</li><li>如果位置$(i,j)$有怪物且其血量大于，则建边：$(i, n+j,1)$</li></ol><p><a href="https://imgchr.com/i/CgClSf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2018/05/20/CgClSf.md.png" alt="CgClSf.md.png"></a></p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sf(x) scanf(<span class="meta-string">"%d"</span>, &amp;x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clr(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, cap;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _to, <span class="keyword">int</span> _nxt, <span class="keyword">int</span> _cap): to(_to), nxt(_nxt), cap(_cap) &#123;&#125;</span><br><span class="line">&#125; E[(N * N + <span class="number">2</span> * N) &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N &lt;&lt; <span class="number">1</span>], tot, d[N &lt;&lt; <span class="number">1</span>], G[N][N], n, S, T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sg &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clr(head, <span class="number">-1</span>);</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> cap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        E[tot] = edge(t, head[s], cap);</span><br><span class="line">        head[s] = tot++;</span><br><span class="line">        E[tot] = edge(s, head[t], <span class="number">0</span>);</span><br><span class="line">        head[t] = tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        clr(d, <span class="number">-1</span>);</span><br><span class="line">        d[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Q;</span><br><span class="line">        Q.push(s);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = E[i].nxt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">                <span class="keyword">if</span> (d[v] == <span class="number">-1</span> &amp;&amp; E[i].cap &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = d[u] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (v == t)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ~d[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == t || !f)</span><br><span class="line">            <span class="keyword">return</span> f;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[s]; ~i; i = E[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">            <span class="keyword">if</span> (d[v] == d[s] + <span class="number">1</span> &amp;&amp; E[i].cap &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> df = dfs(v, t, min(f, E[i].cap));</span><br><span class="line">                <span class="keyword">if</span> (df &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    E[i].cap -= df;</span><br><span class="line">                    E[i ^ <span class="number">1</span>].cap += df;</span><br><span class="line">                    ret += df;</span><br><span class="line">                    f -= df;</span><br><span class="line">                    <span class="keyword">if</span> (!f)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ret)</span><br><span class="line">            d[s] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dinic</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bfs(s, t))</span><br><span class="line">            ret += dfs(s, t, INF);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sg::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        sg::add(S, i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[i][j] &gt;= k)</span><br><span class="line">                sg::add(i, j + n, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sg::add(i + n, T, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sg::dinic(S, T);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">    sf(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            sf(G[i][j]), r = max(r, G[i][j]);</span><br><span class="line">    S = <span class="number">0</span>, T = n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = calc(<span class="number">1</span>), ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = MID(l, r);</span><br><span class="line">        <span class="keyword">if</span> (calc(mid) &lt; b)</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 65536K，其他语言131072K&lt;br&gt; 64bit IO Format: %lld&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="图论" scheme="https://hydrogensulfate.github.io/categories/ACM/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="https://hydrogensulfate.github.io/categories/ACM/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="https://hydrogensulfate.github.io/categories/ACM/%E5%9B%BE%E8%AE%BA/%E7%BD%91%E7%BB%9C%E6%B5%81/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
    
      <category term="图论" scheme="https://hydrogensulfate.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="https://hydrogensulfate.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="https://hydrogensulfate.github.io/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="二分" scheme="https://hydrogensulfate.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CF #480 Div.2 A B C D E</title>
    <link href="https://hydrogensulfate.github.io/2018/05/10/CF-480-Div-2-A-B-C-D-E/"/>
    <id>https://hydrogensulfate.github.io/2018/05/10/CF-480-Div-2-A-B-C-D-E/</id>
    <published>2018-05-10T13:37:16.000Z</published>
    <updated>2018-05-10T15:01:29.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Links-and-Pearls"><a href="#A-Links-and-Pearls" class="headerlink" title="A.Links and Pearls"></a><a href="http://codeforces.com/contest/980/problem/A" target="_blank" rel="noopener">A.Links and Pearls</a></h1><p>题意就是给你一个含有$\textbf{O}$和字符$\;—\;$的成环字符串，问你能不能重排一下使得相邻的$\textbf{O}$之间的$\;—\;$的数量相等，显然要相等只要剩余的横杠数量能被$\textbf{O}$均分掉即可，注意特判下没有$\textbf{O}$的情况。</p><a id="more"></a><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> o = <span class="number">0</span>, _ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'o'</span>)</span><br><span class="line">                ++o;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ++_;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>((_ % o == <span class="number">0</span>) ? <span class="string">"YES"</span> : <span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Marlin"><a href="#B-Marlin" class="headerlink" title="B.Marlin"></a><a href="http://codeforces.com/contest/980/problem/B" target="_blank" rel="noopener">B.Marlin</a></h1><p>题意就是给你一个$4\times n$的空地图，放$k$个障碍物，使得从$(1,1)$到$(4,n)$和$(4,1)$到$(1,n)$的最短路数量相同，感觉是个思维题，可以发现肯定不用去考虑具体的最短路数量是多少，而是考虑如何放置这$k$个障碍物使得对两条路线造成的影响相同。</p><ol><li>如果$k$是偶数，显然对称地放即可。</li><li>如果$k$是奇数，<ol><li>如果$k \le n-2$，那么显然对称地放到第一行即可。</li><li>否则把多出来的放到第二行，从两边向中间放，从右边开始，因为一旦封锁了右边，最短路就不会经过第三行，造成的方案损失就相等了。</li></ol></li></ol><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">char</span> s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, i, j;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        CLR(s, <span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt = k &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(k &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                s[<span class="number">1</span>][i + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                s[<span class="number">2</span>][i + <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= n - <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s[<span class="number">1</span>][n &gt;&gt; <span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (k - <span class="number">1</span>) / <span class="number">2</span>; ++i)</span><br><span class="line">                    s[<span class="number">1</span>][(n &gt;&gt; <span class="number">1</span>) + <span class="number">1</span> + i] = s[<span class="number">1</span>][(n &gt;&gt; <span class="number">1</span>) - <span class="number">1</span> - i] = <span class="string">'#'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> f = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> g[<span class="number">2</span>] = &#123;<span class="number">1</span>, n - <span class="number">2</span>&#125;;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - <span class="number">2</span>; ++i)</span><br><span class="line">                    --k, s[<span class="number">1</span>][i] = <span class="string">'#'</span>;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f)</span><br><span class="line">                        s[<span class="number">2</span>][g[f] - r] = <span class="string">'#'</span>, ++r;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        s[<span class="number">2</span>][g[f] + l] = <span class="string">'#'</span>, ++l;</span><br><span class="line">                    f ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%c%s"</span>, s[i][j], j == n - <span class="number">1</span> ? <span class="string">"\n"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Posterized"><a href="#C-Posterized" class="headerlink" title="C.Posterized"></a><a href="http://codeforces.com/contest/980/problem/C" target="_blank" rel="noopener">C.Posterized</a></h1><p>题意（看了好一会儿才懂）就是给你$n$个颜色用数值$1…256$表示，将他们分配到长度不超过$k$的连续集合中，求最后字典序最小的分配方案。一个分配方案用该连续区间中的任意一个颜色代表（显然优先用最左边的颜色）。</p><p>然后感觉这题是个YY题啊，贪心地看看每一个$color_i$往前考虑$k$个位置，贪心地把颜色归靠左的位置去。用并查集判断一下这个颜色是否被归并过，它所在的集合大小是多少，如果还能容纳当前的颜色，当然也是符合条件的。</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>, M = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], belong[N];</span><br><span class="line"><span class="keyword">int</span> pre[M], sz[M], rev[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; ++i)</span><br><span class="line">        sz[i] = <span class="number">1</span>, pre[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fd</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pre[n] == n ? n : pre[n] = fd(pre[n]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mg</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = fd(a), b = fd(b);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        swap(a, b);</span><br><span class="line">    <span class="keyword">if</span> (a != b)</span><br><span class="line">    &#123;</span><br><span class="line">        sz[a] += sz[b];</span><br><span class="line">        sz[b] = <span class="number">0</span>;</span><br><span class="line">        pre[b] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, i;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k))</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fd(a[i]) != a[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> ch = a[i];</span><br><span class="line">            <span class="keyword">int</span> fc = fd(a[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = a[i]; col &gt;= <span class="number">0</span> &amp;&amp; col &gt;= a[i] - k + <span class="number">1</span>; --col)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> f = fd(col);</span><br><span class="line">                <span class="keyword">if</span> (f == col &amp;&amp; sz[f] + sz[fc] &lt;= k)</span><br><span class="line">                    ch = col;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = a[i]; col &gt;= <span class="number">0</span> &amp;&amp; col &gt;= ch; --col)</span><br><span class="line">                mg(ch, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, fd(a[i]), <span class="string">" \n"</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Perfect-Groups"><a href="#D-Perfect-Groups" class="headerlink" title="D.Perfect Groups"></a><a href="http://codeforces.com/contest/980/problem/D" target="_blank" rel="noopener">D.Perfect Groups</a></h1><p>题意就是给你$n$个数，对$n\times (n+1)/2$个子区间都计算出其最小划分的集合数$k_i$，使得子区间被划分之后集合中任意两个数相乘为平方数。</p><p>看题解发现解法不难，就是有坑点比较猥琐而且常数比较大的算法容易超时。首先容易想到把数进行质数分解，得到质数底数及其对应指数，显然只要将奇数指数与$1$等价，偶数指数与$0$等价，然后这样每一个数$a_i$可以变换得到新的数$b_i$，然后考虑由这种$b_i$们组成的集合，怎么划分才是最小的，显然要成为平方数只能是双方指数同奇偶性，因此把相等的$b_i$划分到同一个集合中，也就是说这个集合中不同的数就是最小的划分数$k$。那么这样以来就是$O(n^2)$枚举同时维护子区间内不同数的个数，这里需要注意的坑点是如果区间内有$0$且不全为$0$，就不能考虑$0$，因为$0$可以被任意划分。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="comment">//typedef complex&lt;double&gt; cpx;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], ans[N], num[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;st;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">G</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> neg;</span><br><span class="line">    n &lt; <span class="number">0</span> ? neg = <span class="number">-1</span>, n = -n : neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                t ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t)</span><br><span class="line">                w *= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w * n * neg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> n, i, j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a + i);</span><br><span class="line">        num[i] = a[i];</span><br><span class="line">        a[i] = G(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (!st.count(a[i]))</span><br><span class="line">            st.insert(pii(a[i], ++id));</span><br><span class="line">        a[i] = st[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt.reset();</span><br><span class="line">        <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt;= n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[j] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ans[max(sz, <span class="number">1</span>)];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!cnt[a[j]])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt[a[j]] = <span class="number">1</span>;</span><br><span class="line">                ++sz;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ans[sz];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="E-The-Number-Games"><a href="#E-The-Number-Games" class="headerlink" title="E.The Number Games"></a><a href="http://codeforces.com/contest/980/problem/E" target="_blank" rel="noopener">E.The Number Games</a></h1><p>题意就是给你$n$个点的<strong>树</strong>，每一个点$i$的权值为$2^i$，从中删掉$k$个点使得剩下的子图连通，使得最后留下的子图权值和最大，输出删除的点。</p><p>一开始感觉这题不就是贪心用<code>pq</code>删掉标号小的拓扑排序吗，实际上并不是这样的简单贪心，由于权值的特殊性，可以发现保留第$i$个点，比删掉剩下的$i-1$个点要优，因此应从大到小去考虑保留哪些点。假设当前要保留点$i$，那么还要保留的点是$i$到子图路径上的所有点（这样才能时刻保持子图连通性），那么就用<code>DFS</code>和<code>倍增</code>预处理一下路径长度和每个节点的$k$倍祖先，每次倍增找到第一个在子图中的祖先，保留路径上的点个数就是$dep[i] - dep[ancestor]$，可以保留的话就暴力把路径上所有点都标记为保留即可。</p><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _to, <span class="keyword">int</span> _nxt): to(_to), nxt(_nxt) &#123;&#125;</span><br><span class="line">&#125; E[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">int</span> dep[N], vis[N], fa[N][<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(head, <span class="number">-1</span>);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[tot] = edge(t, head[s]);</span><br><span class="line">    head[s] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    dep[u] = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (v != f)</span><br><span class="line">            dfs(v, u, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[x] || !x)</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    del(fa[x][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k, i, a, b, j;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b);</span><br><span class="line">        add(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = n - k - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line">    vis[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span> &amp;&amp; res &gt; <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> x = i;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">20</span>; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (fa[x][j] &amp;&amp; !vis[fa[x][j]])</span><br><span class="line">                x = fa[x][j];</span><br><span class="line">        &#125;</span><br><span class="line">        x = fa[x][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> kpcnt = dep[i] - dep[x];</span><br><span class="line">        <span class="keyword">if</span> (res &lt; kpcnt)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        del(i);</span><br><span class="line">        res -= kpcnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Links-and-Pearls&quot;&gt;&lt;a href=&quot;#A-Links-and-Pearls&quot; class=&quot;headerlink&quot; title=&quot;A.Links and Pearls&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/contest/980/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A.Links and Pearls&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题意就是给你一个含有$\textbf{O}$和字符$\;—\;$的成环字符串，问你能不能重排一下使得相邻的$\textbf{O}$之间的$\;—\;$的数量相等，显然要相等只要剩余的横杠数量能被$\textbf{O}$均分掉即可，注意特判下没有$\textbf{O}$的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="比赛" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="DFS" scheme="https://hydrogensulfate.github.io/tags/DFS/"/>
    
      <category term="并查集" scheme="https://hydrogensulfate.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="倍增" scheme="https://hydrogensulfate.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="贪心" scheme="https://hydrogensulfate.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛16 E 求值</title>
    <link href="https://hydrogensulfate.github.io/2018/04/28/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B16-E-%E6%B1%82%E5%80%BC/"/>
    <id>https://hydrogensulfate.github.io/2018/04/28/牛客练习赛16-E-求值/</id>
    <published>2018-04-27T16:41:58.000Z</published>
    <updated>2018-04-28T03:09:49.756Z</updated>
    
    <content type="html"><![CDATA[<p>题目描述</p><p>给定$n$个数字$a_1, a_2, …, a_n$。</p><a id="more"></a><p>定义$f(l, r)$ = $a_l | a_{l+1}| … | a_r$。<br>现在枚举$(1 \le l \le r \le n)$，问不同的$f$值一共有多少个。</p><p>输入描述:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一行一个整数n表示数组大小 (1 &lt;= n &lt;= 100,000)；</span><br><span class="line">第二行n个整数满足0 &lt;= ai &lt;= 1000,000。</span><br></pre></td></tr></table></figure><p>输出描述:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一个整数表示不同的f值一共有多少个。</span><br></pre></td></tr></table></figure><p>示例1</p><p>输入</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 0</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p>示例2</p><p>输入</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 1 2 9 10</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><p>题目链接：<a href="https://www.nowcoder.com/acm/contest/84/E" target="_blank" rel="noopener">E.求值</a></p><p>赛后补题才会的（为什么感觉这题好像哪里见过233），枚举按位或的起始位置$L$，那么$a[L]$的第$i$位一旦在向右或的过程中变为$1$，那么之后这位再为$1$的数就不会产生贡献了，也就是说只有第一次让某位变$1$的数才有贡献，那么可以与预处理出第$i$个数字第$j$位向右的第一个（位置$i$本身不算）第$j$位同样为$1$的位置$i’$，对于所有的数，显然最坏情况是把所有位全或为$1$就可以停止了，那么枚举$a[L]$之后再得到$a[L]$所有位开始改变的第一个位置，<strong>按位置顺序</strong>去或这些有贡献的位置即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> arr[N], cnt[<span class="number">1</span> &lt;&lt; <span class="number">20</span>], pos[N][<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, j;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, arr + i);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span> ((arr[i] &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                pos[i][j] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pos[i][j])</span><br><span class="line">                pos[i][j] = pos[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;bitpos;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (++cnt[s] == <span class="number">1</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">        bitpos.clear();</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[pos[i + <span class="number">1</span>][j]])</span><br><span class="line">                bitpos.pb(pos[i + <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(all(bitpos));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;idx : bitpos)</span><br><span class="line">        &#123;</span><br><span class="line">            s |= arr[idx];</span><br><span class="line">            <span class="keyword">if</span> (++cnt[s] == <span class="number">1</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;给定$n$个数字$a_1, a_2, …, a_n$。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Python学习笔记_day1</title>
    <link href="https://hydrogensulfate.github.io/2018/04/25/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-day1/"/>
    <id>https://hydrogensulfate.github.io/2018/04/25/Python学习笔记-day1/</id>
    <published>2018-04-25T12:30:06.000Z</published>
    <updated>2019-10-29T08:09:48.507Z</updated>
    
    <content type="html"><![CDATA[<p>最近在上<code>Python</code>实训课，就随堂学习学习一下基本的<code>Python</code>语法，发现这个语言确实挺方便的，不是一个复杂的语言，甚至还可以很方便得写类和继承类。然后老师也讲了一些知识，整理了一下</p><a id="more"></a><h1 id="Python的class"><a href="#Python的class" class="headerlink" title="Python的class"></a><code>Python</code>的class</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name = <span class="string">"大人"</span></span><br><span class="line">    __odername = <span class="string">"2"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Created!"</span>)</span><br><span class="line">        print(self.__odername)</span><br><span class="line">        self.__odername = <span class="number">3</span></span><br><span class="line">        print(self.__odername)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Deleted!"</span>)</span><br><span class="line">        self.__odername = <span class="number">1</span></span><br><span class="line">        print(self.__odername)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"吃货"</span>, self.__odername)<span class="comment">#公有成员变量</span></span><br></pre></td></tr></table></figure><ol><li><p><code>class</code>的定义如代码所示。</p></li><li><p>非双下划线开头的变量/函数名相当于<code>public</code>的成员变量/函数，而用<code>__</code>作变量名/函数名开头的会被视为私有<code>private</code>成员变量/函数，示例代码中<code>name</code>就是<code>public</code>类型，而<code>__odername</code>是private类型。</p></li><li><p><code>self</code>参数相当于<code>Java</code>中的<code>this</code>，要使用本身类中的变量不像<code>C</code>语言在成员函数中直接写就行了，要用<code>self.xxxxx</code>来调用。</p></li><li><p><code>__init__</code>函数和<code>__del__</code>私有成员函数可以看作<code>C++</code>的构造和析构函数，在实例创建和消亡时会自动调用。</p></li><li><p>类的继承用括号实现，比如让<code>class B</code>继承<code>class A</code>，那么就可以这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>：</span></span><br><span class="line"><span class="class">......</span></span><br></pre></td></tr></table></figure><p>然后在<code>B</code>中写同名函数会覆盖<code>A</code>中的同名函数</p></li></ol><h1 id="遇到的一点问题"><a href="#遇到的一点问题" class="headerlink" title="遇到的一点问题"></a>遇到的一点问题</h1><p><code>Python</code>中创建$n*m$的二维数组，一开始我想当然地去用一维的长度为$m$的<code>list</code>扔$n$次到另一个$list$中，这样似乎没有什么问题，实际上想去修改某一个位置的值的时候会发现这一列全被修改了。去百度了一下发现其中涉及到一些引用的东西，这里就不细讲了，说下正确的做法之一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br></pre></td></tr></table></figure><p>这样就创建好了一个$n*m$的二维数组$arr[n][m]$了。</p><p>然后做题的时候读取一行的数据，可以把一行用<code>read = input().split()</code>（默认作为字符串<code>str</code>类型）读取进来并用<code>split()</code>（默认空格为分隔符）分割完毕，然后用下标访问读取的第$i$个元素，比如输入形式是<code>数字 字符串 数字</code>，那就可以这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read = input().split()</span><br><span class="line">n, str, m = int(read[<span class="number">0</span>]), read[<span class="number">1</span>], int(read[<span class="number">2</span>])</span><br><span class="line">print(n, str, m)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在上&lt;code&gt;Python&lt;/code&gt;实训课，就随堂学习学习一下基本的&lt;code&gt;Python&lt;/code&gt;语法，发现这个语言确实挺方便的，不是一个复杂的语言，甚至还可以很方便得写类和继承类。然后老师也讲了一些知识，整理了一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="python" scheme="https://hydrogensulfate.github.io/categories/%E5%AD%A6%E4%B9%A0/python/"/>
    
    
      <category term="python" scheme="https://hydrogensulfate.github.io/tags/python/"/>
    
      <category term="学习" scheme="https://hydrogensulfate.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>HDU 2082 找单词（FFT优化母函数乘法）</title>
    <link href="https://hydrogensulfate.github.io/2018/04/24/HDU-2082/"/>
    <id>https://hydrogensulfate.github.io/2018/04/24/HDU-2082/</id>
    <published>2018-04-24T02:24:30.000Z</published>
    <updated>2018-04-25T15:33:16.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="找单词"><a href="#找单词" class="headerlink" title="找单词"></a>找单词</h1><p><strong>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 9061    Accepted Submission(s): 6323</strong></p><a id="more"></a><p>Problem Description</p><p>假设有x1个字母A， x2个字母B,….. x26个字母Z，同时假设字母A的价值为1，字母B的价值为2,….. 字母Z的价值为26。那么，对于给定的字母，可以找到多少价值&lt;=50的单词呢？单词的价值就是组成一个单词的所有字母的价值之和，比如，单词ACM的价值是1+3+14=18，单词HDU的价值是8+4+21=33。(组成的单词与排列顺序无关，比如ACM与CMA认为是同一个单词）。</p><p>Input</p><p>输入首先是一个整数N，代表测试实例的个数。<br>然后包括N行数据，每行包括26个&lt;=20的整数x1,x2,…..x26.</p><p>Output</p><p>对于每个测试实例，请输出能找到的总价值&lt;=50的单词数,每个实例的输出占一行。</p><p>Sample Input</p><p>2<br>1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br>9 2 6 2 10 2 2 5 6 1 0 2 7 0 2 2 7 5 10 6 10 2 10 6 1 9</p><p>Sample Output</p><p>7<br>379297</p><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2082" target="_blank" rel="noopener">HDU 2082</a></p><p>没错我就是这么无聊，强行用<code>FFT</code>去（负）优化这个母函数的相乘过程，实际上我调试了非长久，连nan都出现了233，关键在于控制次数界不要超过51即可，不然数组长度不够存。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cpx;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">26</span> * <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line">cpx x[N], y[N], pwm[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> R[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rpos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span><span class="comment">//以n位二进制表示的x的反转之后的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt; n; ++i)</span><br><span class="line">        w = (w &lt;&lt; <span class="number">1</span>) | ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(cpx a[], <span class="keyword">int</span> b, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &lt; e; ++i)</span><br><span class="line">        a[i] = cpx(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cpx* <span class="title">FFT</span><span class="params">(cpx a[], <span class="keyword">int</span> n, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cpx *A = <span class="keyword">new</span> cpx[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        A[i] = a[R[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m  = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        cpx wm = pwm[i];</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">-1</span>)</span><br><span class="line">            wm.imag(-wm.imag());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k += m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">cpx <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (m &gt;&gt; <span class="number">1</span>); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                cpx t = w * A[k + j + (m &gt;&gt; <span class="number">1</span>)], u = A[k + j];</span><br><span class="line">                A[k + j] = u + t;</span><br><span class="line">                A[k + j + (m &gt;&gt; <span class="number">1</span>)] = u - t;</span><br><span class="line">                w *= wm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!~f)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            A[i].real(A[i].real() / n);</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt; N; ++i)</span><br><span class="line">        pwm[i] = cpx(<span class="built_in">cos</span>(<span class="number">2</span> * PI / (<span class="number">1</span> &lt;&lt; i)), <span class="built_in">sin</span>(<span class="number">2</span> * PI / (<span class="number">1</span> &lt;&lt; i)));</span><br><span class="line">    caseT</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> la = <span class="number">1</span>, lb = <span class="number">0</span>, lc = <span class="number">0</span>, n, first = <span class="number">1</span>;</span><br><span class="line">        init(x, <span class="number">0</span>, N);</span><br><span class="line">        cpx * dx, *dy;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line">            <span class="keyword">if</span> (!c)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (first)</span><br><span class="line">            &#123;</span><br><span class="line">                x[<span class="number">0</span>].real(<span class="number">1.0</span>);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= c; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j * i &gt; <span class="number">50</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    x[j * i].real(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                la = min(<span class="number">51</span>, c * i + <span class="number">1</span>);</span><br><span class="line">                first = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                lb = min(<span class="number">51</span>, i * c + <span class="number">1</span>), lc = lb + la - <span class="number">1</span>;</span><br><span class="line">                n = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (n &lt; lc)</span><br><span class="line">                    n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                    R[j] = rpos(j, n);</span><br><span class="line">                init(y, <span class="number">0</span>, N);</span><br><span class="line">                init(x, la, N);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= c; ++j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j * i &gt; <span class="number">50</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    y[j * i].real(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                dx = FFT(x, n, <span class="number">1</span>);</span><br><span class="line">                dy = FFT(y, n, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">                    dx[j] *= dy[j];</span><br><span class="line">                dy = FFT(dx, n, <span class="number">-1</span>);</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; lc; ++j)</span><br><span class="line">                    x[j] = cpx(<span class="keyword">int</span>(dy[j].real() + <span class="number">0.5</span>), <span class="number">0</span>);</span><br><span class="line">                la = min(<span class="number">51</span>, lc);</span><br><span class="line">                init(x, la, N);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">50</span>; ++i)</span><br><span class="line">            ans += <span class="keyword">int</span>(x[i].real() + <span class="number">0.5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;找单词&quot;&gt;&lt;a href=&quot;#找单词&quot; class=&quot;headerlink&quot; title=&quot;找单词&quot;&gt;&lt;/a&gt;找单词&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 9061    Accepted Submission(s): 6323&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="FFT" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/FFT/"/>
    
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="FFT，母函数" scheme="https://hydrogensulfate.github.io/tags/FFT%EF%BC%8C%E6%AF%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HDU 1402 A * B Problem Plus（FFT入门题）</title>
    <link href="https://hydrogensulfate.github.io/2018/04/19/HDU-1402/"/>
    <id>https://hydrogensulfate.github.io/2018/04/19/HDU-1402/</id>
    <published>2018-04-19T15:46:51.000Z</published>
    <updated>2018-04-23T04:54:26.641Z</updated>
    
    <content type="html"><![CDATA[<p> A * B Problem Plus</p><p><strong>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 25113    Accepted Submission(s): 6448</strong><br><a id="more"></a><br>Problem Description</p><p>Calculate A * B.</p><p>Input</p><p>Each line will contain two integers A and B. Process to end of file.<br>Note: the length of each integer will not exceed 50000.</p><p>Output</p><p>For each case, output A * B in one line.</p><p>Sample Input</p><p>1<br>2<br>1000<br>2</p><p>Sample Output</p><p>2<br>2000</p><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1402http://acm.hdu.edu.cn/showproblem.php?pid=1402" target="_blank" rel="noopener">HDU 1402</a></p><p>题意就不说了，主要是讲下如何使用快速傅立叶变换做这入门题。</p><p>快速傅立叶变换（<code>FFT</code>）可以用来快速地求两个多项式的积，就像$(1+x+2x^2)\times (3x+6x^2)=3x+6x^2+3x^2+6x^3+3x^3+6x^4=3x+9x^2+9x^3+6x^4$</p><p>输入是两个多项式的系数，输出是这两个多项式之积的系数（<code>FFT</code>我一开始都不知道它是怎么用的，更不用说去学了）</p><p>那么上述的输入就是 $1\;1\;2$ 和 $0\;3\;6\;$，得到的多项式系数是$0\;3\;9\;9\;6\;0\;0\;0$（注意最低系数要补齐，从$x^0$开始，结果的次数界要为$2$的幂次）</p><p>各种介绍的博客就不说了，百度搜 <code>FFT学习笔记</code>一大堆。这题如果把输入的数看成十进制下的带权求和多项式，那么就可以以多项式的乘法来得到答案的多项式表示，再把这个多项式用十进制转换成答案即可。</p><p>以$1000 \times2$为例，它就是</p><script type="math/tex; mode=display">(\textbf{0}\times 10^0+\textbf{0}\times 10^1+\textbf{0}\times 10^2+\textbf{1}\times 10^3)\times(\textbf{2}\times 10^0)</script><p>这两个多项式的乘积，不过不能一开始就把$10$进制这个$10$代入，应该写成</p><script type="math/tex; mode=display">(\textbf{0}\times x^0+\textbf{0}\times x^1+\textbf{0}\times x^2+\textbf{1}\times x^3)\times(\textbf{2}\times x^0)</script><p>然后把结果的系数用<code>FFT</code>求出来即：</p><script type="math/tex; mode=display">(\textbf{0}\times x^0+\textbf{0}\times x^1+\textbf{0}\times x^2+\textbf{2}\times x^3)</script><p>再把$x=10$代入即可。</p><p>这里有几个细节问题，如果输入的多项式次数界为$a$和$b$，那么结果的次数界应该为$a+b-1$，那么<code>FFT</code>时所用的$2$的幂次的次数界应该要刚好大于等于它。</p><hr><p>又去学了下优化<code>FFT</code>的姿势，把递归版改成了非递归，原理就是直接把一开始的数组按照递归合并时的顺序排序，然后就做一个类似于倍增的合并操作就行了。</p><p>学习的时候发现有几个要注意和改进的地方：</p><ol><li>重复利用某一个<code>complex</code>数组的时候，在当前次数界$n$之后的复数要手动置$0$，否则答案越到后面会偏差越大</li><li>函数参数$f$表示正逆变换，做逆变换的时候可以把要返回的数组乘以$1 \over n$，方便一点。</li><li>可以预处理出所有要用的$cos(2\pi/i)$和$sin(2\pi/i)$的值，速度快一点。</li><li><code>FFT</code>函数可以写成返回一个数组的首地址，这样就可以用指针接收这个地址，方便后续进行操作（数据一大估计得delete 一下23333）</li><li><code>ans</code>数组如果多次使用，其末尾也要清零，否则末尾会遗留下上次可能超过末尾的部分数字。</li></ol><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; cpx;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>;</span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"><span class="keyword">int</span> R[N &lt;&lt; <span class="number">2</span>], ans[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line">cpx x[N &lt;&lt; <span class="number">2</span>], pwm[<span class="number">20</span>];<span class="comment">//pwm是预处理出2*PI/(1&lt;&lt;i)的正弦和余弦值组成的复数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rpos</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span><span class="comment">//以n位二进制表示的x的反转之后的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt; n; ++i)</span><br><span class="line">        w = (w &lt;&lt; <span class="number">1</span>) | ((x &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">cpx* <span class="title">FFT</span><span class="params">(cpx a[], <span class="keyword">int</span> n, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cpx *A = <span class="keyword">new</span> cpx[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        A[i] = a[R[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m  = (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">        <span class="comment">//        cpx wm(cos(2 * PI / m), f * sin(2 * PI / m));</span></span><br><span class="line">        cpx wm = pwm[i];</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="number">-1</span>)</span><br><span class="line">            wm.imag(-wm.imag());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k += m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">cpx <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (m &gt;&gt; <span class="number">1</span>); ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                cpx t = w * A[k + j + (m &gt;&gt; <span class="number">1</span>)], u = A[k + j];</span><br><span class="line">                A[k + j] = u + t;</span><br><span class="line">                A[k + j + (m &gt;&gt; <span class="number">1</span>)] = u - t;</span><br><span class="line">                w *= wm;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!~f)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            A[i].real(A[i].real() / n);</span><br><span class="line">    <span class="keyword">return</span> A;<span class="comment">//返回处理好的数组首地址，后面就可以用了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt; (N &lt;&lt; <span class="number">2</span>); ++i)</span><br><span class="line">        pwm[i] = cpx(<span class="built_in">cos</span>(<span class="number">2</span> * PI / (<span class="number">1</span> &lt;&lt; i)), <span class="built_in">sin</span>(<span class="number">2</span> * PI / (<span class="number">1</span> &lt;&lt; i)));</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%s%s"</span>, a, b))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> la = <span class="built_in">strlen</span>(a), lb = <span class="built_in">strlen</span>(b), lc = la + lb - <span class="number">1</span>, n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &lt; lc)</span><br><span class="line">            n &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            R[i] = rpos(i, n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; la; ++i)</span><br><span class="line">            x[i] = cpx(a[la - <span class="number">1</span> - i] - <span class="string">'0'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = la; i &lt; n; ++i)<span class="comment">//记得清零</span></span><br><span class="line">            x[i] = cpx(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cpx *A = FFT(x, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lb; ++i)</span><br><span class="line">            x[i] = cpx(b[lb - <span class="number">1</span> - i] - <span class="string">'0'</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = lb; i &lt; n; ++i)<span class="comment">//记得清零</span></span><br><span class="line">            x[i] = cpx(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cpx *B = FFT(x, n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            A[i] *= B[i];</span><br><span class="line">        A = FFT(A, n, <span class="number">-1</span>);</span><br><span class="line">        ans[lc] = <span class="number">0</span>;<span class="comment">//记得清零</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            ans[i] = <span class="keyword">int</span>(A[i].real() + <span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lc; ++i)</span><br><span class="line">            ans[i + <span class="number">1</span>] += ans[i] / <span class="number">10</span>, ans[i] %= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (lc &amp;&amp; !ans[lc])</span><br><span class="line">            --lc;</span><br><span class="line">        <span class="keyword">for</span> (i = lc; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">delete</span> []A;</span><br><span class="line">        <span class="keyword">delete</span> []B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; A * B Problem Plus&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)Total Submission(s): 25113    Accepted Submission(s): 6448&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="FFT" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%95%B0%E5%AD%A6/FFT/"/>
    
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/tags/ACM/"/>
    
      <category term="FFT" scheme="https://hydrogensulfate.github.io/tags/FFT/"/>
    
  </entry>
  
  <entry>
    <title>CF #475 Div.2 A B C D</title>
    <link href="https://hydrogensulfate.github.io/2018/04/18/CF-475-Div-2-A-B-C-D/"/>
    <id>https://hydrogensulfate.github.io/2018/04/18/CF-475-Div-2-A-B-C-D/</id>
    <published>2018-04-18T13:47:58.000Z</published>
    <updated>2018-04-19T11:48:24.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Splits"><a href="#A-Splits" class="headerlink" title="A.Splits"></a><a href="http://codeforces.com/contest/964/problem/A" target="_blank" rel="noopener">A.Splits</a></h1><p>题意就是把数$n$用一个不升序列的前一部分和表示，求有几种不同权重的表示，观察一发发现这玩意儿似乎就是除以$2$再加$1$就行了（<del>这题让我知道了交两发只算最晚的那发的2333，原地爆炸</del>）</p><a id="more"></a><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        LL ans = <span class="built_in">ceil</span>(n / <span class="number">2.0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Messages"><a href="#B-Messages" class="headerlink" title="B.Messages"></a><a href="http://codeforces.com/contest/964/problem/B" target="_blank" rel="noopener">B.Messages</a></h1><p>题意就是有$n$个信息，初始价值均为$A$，每个信息在$t_i$的时候会发送给你，你可以选择阅读或者不阅读，不读的话每一分钟会开始扣$B$的价值，读的话就会把总价值加上$A$，然后每分钟总价值还会加上$C\times当前未读信息$，求在$T$分钟之后全部阅读掉的前提下最大的总价值。</p><p>如果$C\ge B$的话显然放到最后总是最优的，读了的话一个信息就少了$C-B$的贡献，不读的话还能加上这个贡献。</p><p>当$C\le B$时，可以考虑全部放到最后一分钟阅读，这样的总价值是最大的。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, A, B, C, T, i;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;n, &amp;A, &amp;B, &amp;C, &amp;T))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t[i]);</span><br><span class="line">        <span class="keyword">if</span> (C &gt;= B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> delay = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">                delay += T - t[i];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, A * n + C * delay - B * delay);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, A * n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Alternating-Sum"><a href="#C-Alternating-Sum" class="headerlink" title="C.Alternating Sum"></a><a href="http://codeforces.com/contest/964/problem/C" target="_blank" rel="noopener">C.Alternating Sum</a></h1><p>题意就是给你一个循环节为$k$的$S_{0…n}$序列，然后求</p><p>$\sum \limits_{i=0}^{n} s_{i} a^{n - i} b^{i}$</p><p>答案对$1e9+9$取模。显然把数列写出来，可以发现如果以前$k$项的和作首项的话，刚好是一个模意义下的等比数列求和，公比是$a^{-k}b^k$，然后题目还是很良心的给你的$n+1$是$k$的整数倍，这样刚好让你用等比数列公式算，当然其中有个坑，当公比为$1$的时候，$1-q$会变成$0$，此时算出来的结果可能会变成$0$，这种情况特判掉就行。另外也可以用矩阵快速幂来求这个等比数列的和。</p><script type="math/tex; mode=display">\begin{pmatrix}  a_{1} & S_1  \\  0&0 \\  \end{pmatrix}  \times  \begin{pmatrix}  1 & 1  \\  0 & a^{-k}b^k \\  \end{pmatrix}^{(n+1)/k-1}  =  \begin{pmatrix}  a_{1} & S_{(n+1)/k}  \\  0 & 0 \\  \end{pmatrix}</script><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> LL mod = <span class="number">1e9</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Mat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL A[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">O</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>][<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">0</span>] = A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">I</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        A[<span class="number">0</span>][<span class="number">1</span>] = A[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat <span class="keyword">operator</span> *(Mat b) &#123;</span><br><span class="line">        Mat c;</span><br><span class="line">        c.O();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">2</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                    c.A[i][j] = (c.A[i][j] + A[i][k] * b.A[k][j]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> Mat <span class="keyword">operator</span>^(Mat a, LL b) &#123;</span><br><span class="line">        Mat r;</span><br><span class="line">        r.I();</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">                r = r * a;</span><br><span class="line">            a = a * a;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat() &#123;&#125;</span><br><span class="line">    Mat(<span class="built_in">initializer_list</span>&lt;LL&gt; v) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : v) &#123;</span><br><span class="line">            A[p / <span class="number">2</span>][p &amp; <span class="number">1</span>] = x;</span><br><span class="line">            ++p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">qpow</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">        a = (a % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">        b = (b % mod + mod) % mod;</span><br><span class="line">    LL r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            r = r * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">mul</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; <span class="number">0</span>)</span><br><span class="line">        a = (a % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">        b = (b % mod + mod) % mod;</span><br><span class="line">    LL r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            r = (r + a) % mod;</span><br><span class="line">        a = (a + a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">inv</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        x = (x % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">return</span> qpow(x, mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, k;</span><br><span class="line">    LL a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%I64d%I64d%d"</span>, &amp;n, &amp;a, &amp;b, &amp;k);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br><span class="line">    LL a1 = <span class="number">0</span>;</span><br><span class="line">    LL inv_a = inv(a);</span><br><span class="line">    LL fa = qpow(a, n), fb = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a1 = (a1 + (s[i] == <span class="string">'+'</span> ? <span class="number">1L</span>L : <span class="number">-1L</span>L) * fa % mod * fb % mod) % mod;</span><br><span class="line">        fa = fa * inv_a % mod;</span><br><span class="line">        fb = fb * b % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    Mat A =</span><br><span class="line">    &#123;</span><br><span class="line">        a1, a1,</span><br><span class="line">        <span class="number">0L</span>L, <span class="number">0L</span>L</span><br><span class="line">    &#125;;</span><br><span class="line">    Mat B =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">1L</span>L, <span class="number">1L</span>L,</span><br><span class="line">        <span class="number">0L</span>L, qpow(inv_a, k)*qpow(b, k) % mod</span><br><span class="line">    &#125;;</span><br><span class="line">    B = B ^ ((n + <span class="number">1</span>) / k - <span class="number">1</span>);</span><br><span class="line">    A = A * B;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, ((A.A[<span class="number">0</span>][<span class="number">1</span>] % mod) + mod) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Destruction-of-a-Tree"><a href="#D-Destruction-of-a-Tree" class="headerlink" title="D.Destruction of a Tree"></a><a href="http://codeforces.com/contest/964/problem/D" target="_blank" rel="noopener">D.Destruction of a Tree</a></h1><p>题意很简单就是让你判断能否通过不停删除偶数度数的点及其连出去的边，最后删完这整颗树。</p><p>刚开始感觉哇这不是无脑<code>BFS</code>吗，燃鹅无脑的我并没有考虑到实际上不同的删点顺序会影响能否成功删完这棵树，所以正确的策略是优先删除靠近叶子结点的点，那么一开始用<code>DFS</code>预处理出每个结点的深度，然后用<code>pq</code>按度数大的优先去<code>BFS</code>即可。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;E[N];</span><br><span class="line"><span class="keyword">int</span> deg[N], n, des[N], p[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pos;</span><br><span class="line"><span class="keyword">int</span> dep[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u] = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : E[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != f)</span><br><span class="line">            dfs(v, u, d + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[s].pb(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pii&gt;Q;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg[i] &amp; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        Q.push(&#123;dep[i], i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = Q.top().second;</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (des[u] || ((deg[u] &gt; <span class="number">0</span>) &amp;&amp; (deg[u] &amp; <span class="number">1</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        des[u] = <span class="number">1</span>;</span><br><span class="line">        pos.push_back(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : E[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (des[v] || (deg[v] &lt;= <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            --deg[v];</span><br><span class="line">            --deg[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;v : E[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (des[v])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (deg[v] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                Q.push(&#123;dep[v], v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">        <span class="keyword">if</span> (p[i])</span><br><span class="line">        &#123;</span><br><span class="line">            add(p[i], i);</span><br><span class="line">            add(i, p[i]);</span><br><span class="line">            ++deg[i];</span><br><span class="line">            ++deg[p[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!p[i])</span><br><span class="line">            dfs(i, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    bfs();</span><br><span class="line">    <span class="keyword">int</span> ans = pos.size();</span><br><span class="line">    <span class="keyword">if</span> (ans != n)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : pos)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Splits&quot;&gt;&lt;a href=&quot;#A-Splits&quot; class=&quot;headerlink&quot; title=&quot;A.Splits&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/contest/964/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A.Splits&lt;/a&gt;&lt;/h1&gt;&lt;p&gt;题意就是把数$n$用一个不升序列的前一部分和表示，求有几种不同权重的表示，观察一发发现这玩意儿似乎就是除以$2$再加$1$就行了（&lt;del&gt;这题让我知道了交两发只算最晚的那发的2333，原地爆炸&lt;/del&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="比赛" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="数学" scheme="https://hydrogensulfate.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="逆元" scheme="https://hydrogensulfate.github.io/tags/%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>CF Educational #42 A B C D F</title>
    <link href="https://hydrogensulfate.github.io/2018/04/12/CF-Educational-42-A-B-C-D-F/"/>
    <id>https://hydrogensulfate.github.io/2018/04/12/CF-Educational-42-A-B-C-D-F/</id>
    <published>2018-04-12T11:31:08.000Z</published>
    <updated>2018-04-12T12:18:26.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-Equator"><a href="#A-Equator" class="headerlink" title="A.Equator"></a><a href="http://codeforces.com/contest/962/problem/A" target="_blank" rel="noopener">A.Equator</a></h1><a id="more"></a><p>坑点在在于<code>int</code>除2的时候是向下取整的所以还是乘以2好……</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200005</span>;</span><br><span class="line">LL arr[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, arr + i);</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t += arr[i];</span><br><span class="line">        <span class="keyword">if</span> (t * <span class="number">2</span> &gt;= sum)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-Students-in-Railway-Carriage"><a href="#B-Students-in-Railway-Carriage" class="headerlink" title="B.Students in Railway Carriage"></a><a href="http://codeforces.com/contest/962/problem/B" target="_blank" rel="noopener">B.Students in Railway Carriage</a></h1><p>题意就是给你$n$个位置，在空位上放置$a$个学生和$b$个运动员使得放置的总人数最多。</p><p>记录一下前一个放的是谁，<strong>贪心</strong>地放和前面一个不冲突的就行。</p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, a, b, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a &amp;&amp; (a &gt;= b))</span><br><span class="line">                &#123;</span><br><span class="line">                    --a;</span><br><span class="line">                    ++c;</span><br><span class="line">                    p = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (b &amp;&amp; b &gt;= a)</span><br><span class="line">                &#123;</span><br><span class="line">                    --b;</span><br><span class="line">                    ++c;</span><br><span class="line">                    p = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="number">1</span> &amp;&amp; b &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --b;</span><br><span class="line">                    ++c;</span><br><span class="line">                    p = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="number">2</span> &amp;&amp; a &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --a;</span><br><span class="line">                    ++c;</span><br><span class="line">                    p = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-Make-a-Square"><a href="#C-Make-a-Square" class="headerlink" title="C.Make a Square"></a><a href="http://codeforces.com/contest/962/problem/C" target="_blank" rel="noopener">C.Make a Square</a></h1><p>题意就是给你一个数$n$删掉最少的位数变成平方数，结果不能带前导$0$</p><p>无脑<code>BFS</code>或者<code>DFS</code>都行，注意判断前导$0$就行。<code>stoll</code>真是好用</p><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x.size() &gt;= <span class="number">1</span> &amp;&amp; x[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LL d = stoll(x);</span><br><span class="line">    LL q = <span class="built_in">sqrt</span>(d);</span><br><span class="line">    <span class="keyword">return</span> q * q == d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &gt;Q;</span><br><span class="line">    Q.push(&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (check(u.first))</span><br><span class="line">            <span class="keyword">return</span> u.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; u.first.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> tt = u.first;</span><br><span class="line">            tt.erase(i, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)tt.size() &gt;= <span class="number">1</span>)</span><br><span class="line">                Q.push(&#123;tt, u.second + <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; bfs(k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="D-Merge-Equals"><a href="#D-Merge-Equals" class="headerlink" title="D.Merge Equals"></a><a href="http://codeforces.com/contest/962/problem/D" target="_blank" rel="noopener">D.Merge Equals</a></h1><p>题意就是给你$n$个数的序列，每次不停地找两个出现次数大于等于$2$的数，拿出其最靠左的两个位置$p1$和$p2$，然后把前面的数加到后面去，消掉前面的，直到不存在出现次数大于等于$2$的数为止。</p><p>实际上是个模拟题，鉴于数据范围稍大，因此用<code>map</code>维护每个数的出现次数，一个堆维护出现次数大于等于$2$的数中最小的数，再用一个<code>map</code>维护每个数及其出现的位置集合，每次相加的新数用二分插入对应的位置即可。</p><h2 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">150005</span>;</span><br><span class="line">LL arr[N];</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt;cnt;</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; &gt;pos;</span><br><span class="line"><span class="built_in">map</span>&lt;LL, <span class="keyword">int</span>&gt;vis;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL v;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> info &amp;t)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> v &gt; t.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;info&gt;Q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%I64d"</span>, arr + i);</span><br><span class="line">        ++cnt[*(arr + i)];</span><br><span class="line">        vis[*(arr + i)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        LL &amp;v = *(arr + i);</span><br><span class="line">        c = cnt[v];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[v] = <span class="number">0</span>;</span><br><span class="line">                Q.push(&#123;v, c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pos[v].pb(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        info u = Q.top();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (cnt[u.v] &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> p1 = pos[u.v][<span class="number">0</span>], p2 = pos[u.v][<span class="number">1</span>];</span><br><span class="line">        pos[u.v].pop_front();</span><br><span class="line">        pos[u.v].pop_front();</span><br><span class="line">        c = (cnt[u.v] -= <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="number">2</span>)<span class="comment">//消掉之后可能下一轮还是这个数，这里要入队一次</span></span><br><span class="line">        &#123;</span><br><span class="line">            Q.push(&#123;u.v, c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[p2] += arr[p1];</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(all(pos[arr[p2]]), p2);</span><br><span class="line">        pos[arr[p2]].insert(it, p2);</span><br><span class="line">        c = ++cnt[*(arr + p2)];</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Q.push(&#123;arr[p2], c&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[p1] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt;ans;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] != <span class="number">-1</span>)</span><br><span class="line">            ans.pb(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;x : ans)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%I64d "</span>, x);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F-Simple-Cycles-Edges"><a href="#F-Simple-Cycles-Edges" class="headerlink" title="F.Simple Cycles Edges"></a><a href="http://codeforces.com/contest/962/problem/F" target="_blank" rel="noopener">F.Simple Cycles Edges</a></h1><p>题意就是给你$n$个点，$m$条边的无自环，无重边的<strong>无向图</strong>，求所有简单环上的边。</p><p>看到图论题立马上去刚了，燃鹅退役前只写过边双连通，这题是点双连通（刚不动刚不动），然后去学了一下点双连通。</p><p>首先可以容易发现简单环总是边数等于点数的，但是不一定如此，比如：</p><p><a href="https://simimg.com/i/NhSSq" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/04/12/NhSSq.md.png" alt="NhSSq.md.png"></a></p><p>这个图里显然有两个简单环，但是在同一个边双连通分量中，因此不能用边双连通去缩点，而要用点双连通，大体做法就是把每个点双连通分量求出来，看看分量中的边数是否等于点数即可。这样一来上图的两个分量刚好符合条件。</p><h2 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#pragma GCC optimize(2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) (x&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((x&lt;&lt;1)+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID(x,y) ((x+y)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(a) (a).begin(),(a).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb(x) push_back(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLR(arr,val) memset(arr,val,sizeof(arr))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IO ios::sync_with_stdio(false);cin.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> caseT int _T;scanf(<span class="meta-string">"%d"</span>,&amp;_T);for (int q=1; q&lt;=_T; ++q)</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt, id;</span><br><span class="line">    edge() &#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> _to, <span class="keyword">int</span> _nxt, <span class="keyword">int</span> _id): to(_to), nxt(_nxt), id(_id) &#123;&#125;</span><br><span class="line">&#125; E[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[N], tot;</span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], st[N], top, ts, ins[N], pbc_cnt, road[N][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;est;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;pbc_edge[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CLR(head, <span class="number">-1</span>);</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    E[tot] = edge(t, head[s], id);</span><br><span class="line">    head[s] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = low[u] = ++ts;</span><br><span class="line">    ins[u] = <span class="number">1</span>;</span><br><span class="line">    st[top++] = u;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = E[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        v = E[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            est.push(i);</span><br><span class="line">            tarjan(v, u);</span><br><span class="line">            low[u] = min(low[u], low[v]);</span><br><span class="line">            <span class="keyword">if</span> (low[v] &gt;= dfn[u])<span class="comment">//u为割点</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++pbc_cnt;</span><br><span class="line">                <span class="keyword">int</span> eid;</span><br><span class="line">                <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                    eid = est.top();</span><br><span class="line">                    est.pop();</span><br><span class="line">                    pbc_edge[pbc_cnt].pb(E[eid].id);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (E[eid].id != E[i].id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dfn[v] &lt; dfn[u] &amp;&amp; v != f)</span><br><span class="line">        &#123;</span><br><span class="line">            est.push(i);</span><br><span class="line">            low[u] = min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, a, b, i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">        add(a, b, i);</span><br><span class="line">        add(b, a, i);</span><br><span class="line">        road[i][<span class="number">0</span>] = a, road[i][<span class="number">1</span>] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">            tarjan(i, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;ans;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= pbc_cnt; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;eid : pbc_edge[i])</span><br><span class="line">        &#123;</span><br><span class="line">            p.insert(road[eid][<span class="number">0</span>]);</span><br><span class="line">            p.insert(road[eid][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pbc_edge[i].size() == p.size())</span><br><span class="line">            ans.insert(ans.end(), all(pbc_edge[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(all(ans));</span><br><span class="line">    <span class="keyword">int</span> sz = ans.size();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sz);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sz; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, ans[i], <span class="string">" \n"</span>[i == sz - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;A-Equator&quot;&gt;&lt;a href=&quot;#A-Equator&quot; class=&quot;headerlink&quot; title=&quot;A.Equator&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://codeforces.com/contest/962/problem/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A.Equator&lt;/a&gt;&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/categories/ACM/"/>
    
      <category term="比赛" scheme="https://hydrogensulfate.github.io/categories/ACM/%E6%AF%94%E8%B5%9B/"/>
    
    
      <category term="BFS" scheme="https://hydrogensulfate.github.io/tags/BFS/"/>
    
      <category term="图论" scheme="https://hydrogensulfate.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="ACM" scheme="https://hydrogensulfate.github.io/tags/ACM/"/>
    
      <category term="思维" scheme="https://hydrogensulfate.github.io/tags/%E6%80%9D%E7%BB%B4/"/>
    
      <category term="Tarjan" scheme="https://hydrogensulfate.github.io/tags/Tarjan/"/>
    
  </entry>
  
</feed>
